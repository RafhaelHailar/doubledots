{
  "version": 3,
  "sources": ["x/embrace/v1.js", "x/dotRule/dot.js", "x/er/v1.js", "x/fetch/v1.js", "x/PropagationSimple/prop.js"],
  "sourcesContent": ["class LoopCube {\n  static compareSmall(old, now) {\n    const exact = new Array(now.length);\n    const unused = [];\n    if (!old?.length)\n      return { exact, unused };\n    main: for (let o = 0; o < old.length; o++) {\n      for (let n = 0; n < now.length; n++) {\n        if (!exact[n] && old[o] === now[n]) {\n          exact[n] = o;\n          continue main;\n        }\n      }\n      unused.push(o);\n    }\n    return { exact, unused };\n  }\n\n  constructor(embrace) {\n    this.embrace = embrace;\n    this.now = [];\n    this.nowEmbraces = [];\n  }\n\n  step(now = []) {\n    const old = this.now;\n    const oldEmbraces = this.nowEmbraces;\n    this.now = now;\n    const { exact, unused } = LoopCube.compareSmall(old, now);\n    const embraces = new Array(now.length);\n    const changed = [];\n    for (let n = 0; n < exact.length; n++) {\n      const o = exact[n];\n      if (o != null) {\n        embraces[n] = oldEmbraces[o];\n      } else {\n        changed.push(n);\n        embraces[n] = unused.length ? oldEmbraces[unused.pop()] : this.embrace.clone();\n      }\n    }\n    this.nowEmbraces = embraces;\n    const removes = unused.map(o => oldEmbraces[o]);\n    return { embraces, removes, changed };\n  }\n}\n\nclass EmbraceGet {\n  constructor(param) {\n    this.param = param;\n  }\n  get params() {\n    return { [this.param]: this.param };\n  }\n  run(argsDict, dataIn, node, ancestor) {\n    return argsDict[this.param];\n  }\n\n  static make(str) {\n    return str.indexOf(\" \") === -1 && new EmbraceGet(str);\n  }\n}\n\nclass EmbraceTextNode {\n  constructor(segs) {\n    !segs[0] && segs.shift();\n    !segs[segs.length - 1] && segs.pop();\n    this.segs = segs;\n  }\n\n  get params() {\n    const res = {};\n    for (let E of this.segs)\n      if (E instanceof EmbraceGet)\n        for (let param in E.params)\n          res[param] = param;\n    return res;\n  }\n\n  run(argsDict, dataIn, node, ancestor) {\n    let txt = \"\";\n    for (let s of this.segs)\n      txt += typeof s == \"string\" ? s : s.run(argsDict, dataIn, node, ancestor);\n    node.textContent = txt;\n  }\n\n  static make(txt) {\n    //split the segment\n    const segs = txt.split(/{{([^}]+)}}/);\n    if (segs.length === 1)\n      return;\n    //convert splits to bigEs\n    for (let i = 1; i < segs.length; i += 2) {\n      segs[i] = EmbraceGet.make(segs[i].trim()) ?? `{{${segs[i]}}}`;\n      if (!(segs[i] instanceof EmbraceGet))\n        console.error(`invalid embrace expression: ${segs[i]}`);//todo throw error in the EmbraceExp\n    }\n    return new EmbraceTextNode(segs);\n  }\n}\n\nclass EmbraceCommentFor {\n  constructor(templ, dollarName, listName) {\n    this.listName = listName;\n    this.dollarName = dollarName;\n    this.d = `$${dollarName}`;\n    this.dd = `$$${dollarName}`;\n    this.templ = templ.content;\n    templ.remove(); //remove the template from the Dom.\n    this.cube = new LoopCube(EmbraceRoot.make(this.templ));\n  }\n\n  get params() {\n    return { [this.listName]: this.listName };\n  }\n\n  run(argsDictionary, dataObject, node, ancestor) {\n    const now = argsDictionary[this.listName];\n    const { embraces, removes, changed } = this.cube.step(now);\n    for (let n of removes)\n      for (let c of n.nodes) //todo make a prop list on the EmbraceRoot to get all the childNodes only.\n        if (!(c instanceof Attr))\n          c.remove();\n    node.after(...embraces.map(e => e.template));\n    for (let i of changed) {\n      dataObject[this.d] = now[i];\n      dataObject[this.dd] = i;\n      embraces[i].run(Object.assign({}, argsDictionary), dataObject, undefined, ancestor);\n    }\n  }\n\n  //naive, no nested control structures yet. no if. no switch. etc. , untested against errors.\n  //startUpTime\n  static make(txt, tmpl) {\n    const ctrlFor = txt.match(/{{\\s*for\\s*\\(\\s*([^\\s]+)\\s+of\\s+([^\\s)]+)\\)\\s*}}/);\n    if (ctrlFor) {\n      const [_, dollarName, listName] = ctrlFor;\n      return new EmbraceCommentFor(tmpl, dollarName, listName);\n    }\n  }\n}\n\nclass DomBranch {\n\n  static gobble(n) {\n    let txt = n.textContent.trim();\n    if (!txt.endsWith(\"{\"))\n      return;\n    const res = document.createElement(\"template\");\n    res.setAttribute(\"start\", txt);\n    n.parentNode.replaceChild(n, res);\n    for (let n = res.nextSibling; n;) {\n      if (n instanceof Comment) {\n        txt = n.textContent.trim();\n        if (txt[0] === \"}\") {\n          res.setAttribute(\"end\", txt);\n          n.remove();\n          break;\n        }\n        DomBranch.gobble(n);  //try to gobble recursively\n      }\n      const m = n.nextSibling;\n      res.content.append(n);\n      n = m;\n    }\n    DomBranch.subsume(res.content);\n  }\n\n  static nextUp(n) {\n    while (n = n.parentNode)\n      if (n.nextSibling)\n        return n.nextSibling;\n  }\n\n  static subsume(n) {\n    for (; n; n = n.firstChild ?? n.nextSibling ?? DomBranch.nextUp(n))\n      if (n instanceof Comment)\n        DomBranch.gobble(n);\n  }\n}\n\nclass EmbraceRoot {\n\n  static flatDomNodesAll(docFrag) {\n    const res = [];\n    const it = document.createNodeIterator(docFrag, NodeFilter.SHOW_ALL);\n    for (let n; n = it.nextNode();) {\n      res.push(n);\n      if (n instanceof Element)\n        for (let a of n.attributes)\n          res.push(a);\n    }\n    return res;\n  }\n\n  static paramDict(listOfExpressions) {\n    const params = {};\n    for (let e of listOfExpressions.filter(Boolean))\n      for (let p in e.params)\n        params[p] ??= p.split(\".\");\n    return params;\n  }\n\n  static listOfExpressions(listOfNodes) {\n    return listOfNodes.map(n => {\n      if (n instanceof Text || n instanceof Attr)\n        return EmbraceTextNode.make(n.textContent);\n      if (n instanceof Comment)\n        return EmbraceCommentFor.make(n.textContent, n.nextSibling);\n    });\n  }\n\n  constructor(docFrag) {\n    this.template = docFrag;\n    this.nodes = EmbraceRoot.flatDomNodesAll(docFrag);\n  }\n\n  clone() {\n    const e = new EmbraceRoot(this.template.cloneNode(true));\n    e.expressions = this.expressions;\n    e.paramsDict = this.paramsDict;\n    return e;\n  }\n\n  run(argsDictionary, dataObject, _, ancestor) {\n    //1. make the argumentsDictionary\n    for (let param in this.paramsDict)\n      argsDictionary[param] ??= this.paramsDict[param].reduce((o, p) => o?.[p], dataObject);\n    //2. prep and run rules\n    for (let ex, n, i = 0; i < this.expressions.length; i++)\n      if (ex = this.expressions[i])\n        if (n = this.nodes[i])\n          if (n instanceof Attr ? ancestor.contains(n.ownerElement) : ancestor.contains(n))\n            ex.run(argsDictionary, dataObject, n, ancestor);\n  }\n\n  static make(docFrag) {\n    const e = new EmbraceRoot(docFrag);\n    e.expressions = EmbraceRoot.listOfExpressions(e.nodes);\n    e.paramsDict = EmbraceRoot.paramDict(e.expressions);\n    return e;\n  }\n}\n\nexport function embrace(templ, dataObject) {\n  if (!this.__embraceRoot) {\n    //This should happen only once, when a piece of DOM is converted to <template>\n    //therefore => move into _t:\n    DomBranch.subsume(templ);\n    this.__embraceRoot = EmbraceRoot.make(templ);\n    this.ownerElement.append(this.__embraceRoot.template);\n  }\n  this.__embraceRoot.run({}, dataObject, 0, this.ownerElement);\n}", "const scopes = {\n  \".\": \"this.\",\n  \"e.\": \"window.eventLoop.event.\",\n  \"t.\": \"window.eventLoop.event.target.\",\n  \"w.\": \"window.\",\n  \"d.\": \"window.document.\",\n  // \"i.\": \"args[0].\",  //todo implement this instead of .oi\n  // \"i(0-9)+\": \"args[$1].\",//todo implement this instead of .oi\n  \"oi.\": \"oi.\",\n  \"at.\": \"window.eventLoop.attribute.\", //useful when dash rules have moved the origin\n  \"el.\": \"window.eventLoop.attribute.ownerElement.\", //todo same as this.ownerElement??\n  \"this.\": \"this.\",\n  \"window.\": \"window.\",\n  \"document.\": \"document.\"\n};\n\n//todo must rename oi to i, because of the change of structures.\nfunction processRef(prop) {\n  for (let prefix in scopes)\n    if (prop.startsWith(prefix))\n      return DoubleDots.kebabToPascal(scopes[prefix] + prop.slice(prefix.length));\n}\n\nconst primitives =\n  /^((-?\\d+(\\.\\d+)?([eE][-+]?\\d+)?)|this|window|document|i|e|true|false|undefined|null)$/;\n\nfunction textToExp(txt) {\n  let [prop, ...args] = txt.split(\"_\");\n  const ref = processRef(prop);\n  args = args.map(arg => processRef(arg) || primitives.test(arg) ? arg : `\"${arg}\"`);\n  const sargs = args.join(\", \");\n  const setter = !args.length ? \"\" : args.length === 1 ? `=${sargs}` : `=[${sargs}]`;\n  return `(${ref} instanceof Function ? ${ref}(${sargs}) : (${ref}${setter}))`;\n}\n\nfunction DotReactionRule(fullname) {\n  const exp = textToExp(fullname);\n  const code = `function dotReaction(oi) { return ${exp}; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//basic filters\nfunction BreakOnFalseReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} || EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\nfunction BreakOnTrueReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} && EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//jump\nfunction JumpReactionRule(fullname) {\n  const n = parseInt(fullname.slice(2));\n  if (!n || isNaN(n))\n    throw new DoubleDots.SyntaxError(\"ReactionJump only accept positive and negative integers: \" + fullname.slice(2));\n  // return _ => new EventLoop.ReactionJump(n);\n  return DoubleDots.importBasedEval(`_ => new EventLoop.ReactionJump(${n})`);\n}\n\nconst dynamicDots = {};\nfor (let prefix in scopes)\n  dynamicDots[prefix] = DotReactionRule;\ndynamicDots[\"x.\"] = BreakOnFalseReactionRule;\ndynamicDots[\"y.\"] = BreakOnTrueReactionRule;\ndynamicDots[\"j.\"] = JumpReactionRule;\n\nexport { dynamicDots as dynamicsDots };", "class ER {\n  constructor(posts) {\n    this.posts = posts;\n  }\n\n  * parents(ref, type, prop) {\n    for (let [k, v] of Object.entries(this.posts))\n      if (!type || k.startsWith(type))\n        if (prop && Array.isArray(v[prop]) && v[prop].includes(ref))\n          yield k;\n  }\n\n  parent(ref, type, prop) {\n    return this.parents(ref, type, prop).next().value;\n  }\n\n  //todo this can loop forever, when we have a person with a friend \n  //     that has a friend that is the first person. This won't work.\n  //\n  //todo 1. we need to go width first.\n  //todo 2. we need to check the path. If we are going from:\n  //        person / [friends] / person / [friends]\n  //        then we need to stop at the 2nd [friends].\n  //        we should only resolve person[friends] relationship *once*.\n  //        when we meet person[friends] 2nd time, we should just skip it.\n  //        this means that when we meet \"person\" the second time, \n  //        we should skip all the arrays.\n  resolve(key, vars) {\n    const res = Object.assign({}, vars, this.posts[key]);\n    for (let p in res)\n      if (res[p] instanceof Array)\n        res[p] = res[p].map(k => this.resolve(k, vars));\n    return res;\n  }\n}\n\nlet triggers = new DoubleDots.AttrWeakSet();\n\nexport class Er extends AttrCustom {\n  upgrade() {\n    triggers.add(this);\n  }\n}\n\nclass ErEvent extends Event {\n  constructor(type, er) {\n    super(type);\n    this.er = new ER(er);\n  }\n}\n\nexport function er(posts) {\n  eventLoop.dispatchBatch(new ErEvent(\"er\", posts), triggers);\n}", "export async function fetch_json() {\n  return (await fetch(this.value)).json();\n}\nexport async function fetch_text() {\n  return (await fetch(this.value)).text();\n}", "export class WindowTrigger extends AttrListener {\n  get target() { return window; }\n}\n\nexport class DocumentTrigger extends AttrListener {\n  get target() { return document; }\n}\n\nexport class DCLTrigger extends DocumentTrigger {\n  get type() { return \"DOMContentLoaded\"; }\n}\n\nexport class PrePropTrigger extends WindowTrigger { //global _click\n  get type() { return this.trigger.slice(1); } //remove prefix so returns \"click\"\n  get options() { return true; }\n}\n\nexport class PostPropTrigger extends WindowTrigger { //global click_\n  get type() { return this.trigger.slice(-1); } //remove postfix so returns \"click\"\n}\n\nfunction makeAll() {\n  const upCase = s => s[0].toUpperCase() + s.slice(1);\n  const res = {};\n  for (let type of DoubleDots.nativeEvents.element) {\n    type = upCase(type);\n    res[type] = AttrListener;\n    res[\"_\" + type] = PrePropTrigger;\n    res[type + \"_\"] = PostPropTrigger;\n  }\n  for (let type of DoubleDots.nativeEvents.window)\n    res[upCase(type)] = WindowTrigger;\n  for (let type of DoubleDots.nativeEvents.document)\n    res[upCase(type)] = DocumentTrigger;\n  delete res[\"DOMContentLoaded\"];\n  res[\"Domcontentloaded\"] = DCLTrigger;\n  return res;\n}\nexport const dynamicSimpleProp = makeAll();\n\n/**\n# SimplePropagation\n\n>> Note!! You must register the triggers for `custom-event`s too, such as `document.Triggers.define(\"custom-event\", AttrListener);`.\n\nIn HTML events \"propagate\" in the DOM. These events are small data messages that trigger reactions in the form of JS event listener functions.\n\n## Propagation triggers\n\nIn DoubleDots events also propagate in the DOM. DoubleDots use propagation triggers to react to them. For example `click:toggle_open` uses a `click` propagation trigger to react to `click` event and invoke the `:toggle_open` reaction chain.\n\n## `AttrListener`\n\nThe `AttrListener` is a special subtype of `AttrCustom` that handle native event listeners. Most commonly you will only import a set of propagation triggers for native events, and maybe add some of the propagation triggers to your own `custom-event` types. Most DoubleDots environments will deprecate the native event listeners and only allow event listeners to react to propagation triggers that `extends AttrListener`. Both for native events and custom events. \n\n## HowTo: use `custom-event`s in this SimplePropagation setup?\n\nTo `dispatch` and listen for a `custom-event` using SimplePropagation, \nyou must first and only register their triggers:\n\n1. If you only wish to have normal bubble triggers for them, you only register their bubble triggers.\n```js\n  document.Triggers.define(\"custom-event\", AttrListener);  \n```\n\n2. If you wish the event to be a global, you register it as a WindowTrigger.\n```js\n  document.Triggers.define(\"custom-global-event\", WindowTrigger);  \n```\n3. If you wish the event to be global, and you want to use pre- and post-propagation triggers, register all needed triggers.\n```js\n    document.Triggers.define(\"custom-event\", AttrListener);\n    document.Triggers.define(\"_custom-event\", PrePropTrigger);\n    document.Triggers.define(\"custom-event_\", PostPropTrigger);\n```\n\n## DefaultActions, `stopPropagation()` and SimplePropagation\n\nThe SimplePropagation setup enables you to use native default actions normally.\nThis means that you can call `e.preventDefault()` within any reaction chain for that event.\n\nDoubleDots recommend *against* using `e.stopPropagation()` and `e.stopImmediatePropagation()`. But when you use SimplePropagation, you can allow stopPropagation().\n\n## HowTo: `extends AttrListener`\n\nIf you need to implement your own propagation triggers, the `AttrListener` provide the following interface:\n1. `get target()` (default: `this.ownerElement`)\n2. `get type()` (default: `this.trigger`)\n3. `get options()` (default: undefined)\n4. `run(e){...}` (default: `eventLoop.dispatch(e, this)`)\n\n## Performance and consistency\n\nSimplePropagation follows the same logic as native event listeners. This means that:\n1. listeners/triggers can always be removed. This makes sense.\n2. But, *sometimes* listeners can be added and triggered during the same event propagation cycle, *sometimes* not. Listeners added later in the propagation cycle will be triggered, except when they are on the same element in the same phase as the current element.\n3. The sync/async behavior can be confusing, as sometimes each event listener is given its own macro task, sometimes all event listeners are considered *one* macro task, and sometimes the event listeners are considered sync (when dispatched via `dispatchEvent`).\n\nThe overhead per native event listener is not that big. It is quite performant. The only cost is resolving the reaction chain and maintaining the eventLoop state.\n\n## `Event.activeListeners()`\n\nThe AttrListener keeps track of how many listener are active for any event type at any time. Asking `Event.activeListeners(\"click\")` will return the number of active `click` event listeners in the DOM. This method can be used to for example:\n\n1. debug an app to see what it does,\n\n2. to throw error if `dispatchEvent` is called for an event no one is listening for:\n\n```js\nEventTarget.prototype.dispatchEvent(e){\n  if(Event.activeListeners(e.type))\n    throw new DoubleDots.PropagationError(`dispatching event \"${e.type}\" when no one is listening.`);\n  OG.call(this, e);\n}\n```\n*/"],
  "mappings": "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",
  "names": ["embrace", "n", "er"]
}
