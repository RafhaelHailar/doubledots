{
  "version": 3,
  "sources": ["x/brace/v1.js", "x/embrace/v1.js", "x/dotRule/dot.js", "x/er/v1.js", "x/fetch/v1.js", "x/pp/v1.js", "x/PropagationSimple/prop.js", "x/template/v1.js"],
  "sourcesContent": ["function dotPathGet(dotPath, obj) {\n  if (dotPath === \".\")\n    return obj;\n  for (let p of dotPath.split(\".\"))\n    if (!(obj = obj?.[p]))\n      return obj === 0 ? obj : \"\";\n  return obj;\n}\n\nfunction processBraces(txt, post) {\n  return txt.replace(/\\{\\{([^}{]+)\\}\\}/g, (_, expr) => dotPathGet(expr, post));\n}\n\nfunction* bodyTasks(el, triggerName, ii = []) {\n  if (el instanceof Element) {\n    if (ii.length) //skip during first check\n      for (let a of el.attributes)\n        if (a.name.startsWith(triggerName))\n          return;\n    for (let { name, value } of el.attributes)\n      if (value.indexOf(\"{{\") >= 0)\n        yield (n, now) => ii.reduce((e, i) => e.childNodes[i], n).setAttribute(name, processBraces(value, now));\n    for (let i = 0; i < el.childNodes.length; i++)\n      yield* bodyTasks(el.childNodes[i], triggerName, [...ii, i]);\n  } else if (el instanceof Text) {\n    const txt = el.textContent;\n    if (txt.indexOf(\"{{\") >= 0)\n      yield (n, now) => ii.reduce((e, i) => e.childNodes[i], n).textContent = processBraces(txt, now);\n  }\n}\n\nexport function brace(now) {\n  this.__tasks ??= [...bodyTasks(this.ownerElement, this.trigger + \":\")];\n  for (let cb of this.__tasks)\n    cb(this.ownerElement, now);\n  return now;\n}", "class LoopCube {\n  static compareSmall(old, now) {\n    const exact = new Array(now.length);\n    const unused = [];\n    if (!old?.length)\n      return { exact, unused };\n    main: for (let o = 0; o < old.length; o++) {\n      for (let n = 0; n < now.length; n++) {\n        if (!exact[n] && old[o] === now[n]) {\n          exact[n] = o;\n          continue main;\n        }\n      }\n      unused.push(o);\n    }\n    return { exact, unused };\n  }\n\n  constructor(embrace) {\n    this.embrace = embrace;\n    this.now = [];\n    this.nowEmbraces = [];\n  }\n\n  step(now = []) {\n    const old = this.now;\n    const oldEmbraces = this.nowEmbraces;\n    this.now = now;\n    const { exact, unused } = LoopCube.compareSmall(old, now);\n    const embraces = new Array(now.length);\n    const changed = [];\n    for (let n = 0; n < exact.length; n++) {\n      const o = exact[n];\n      if (o != null) {\n        embraces[n] = oldEmbraces[o];\n      } else {\n        changed.push(n);\n        embraces[n] = unused.length ? oldEmbraces[unused.pop()] : this.embrace.clone();\n      }\n    }\n    this.nowEmbraces = embraces;\n    const removes = unused.map(o => oldEmbraces[o]);\n    return { embraces, removes, changed };\n  }\n}\n\nclass EmbraceGet {\n  constructor(param) {\n    this.param = param;\n  }\n  get params() {\n    return { [this.param]: this.param };\n  }\n  run(argsDict, dataIn, node, ancestor) {\n    return argsDict[this.param];\n  }\n\n  static make(str) {\n    return str.indexOf(\" \") === -1 && new EmbraceGet(str);\n  }\n}\n\nclass EmbraceTextNode {\n  constructor(segs) {\n    !segs[0] && segs.shift();\n    !segs[segs.length - 1] && segs.pop();\n    this.segs = segs;\n  }\n\n  get params() {\n    const res = {};\n    for (let E of this.segs)\n      if (E instanceof EmbraceGet)\n        for (let param in E.params)\n          res[param] = param;\n    return res;\n  }\n\n  run(argsDict, dataIn, node, ancestor) {\n    let txt = \"\";\n    for (let s of this.segs)\n      txt += typeof s == \"string\" ? s : s.run(argsDict, dataIn, node, ancestor);\n    node.textContent = txt;\n  }\n\n  static make(txt) {\n    //split the segment\n    const segs = txt.split(/{{([^}]+)}}/);\n    if (segs.length === 1)\n      return;\n    //convert splits to bigEs\n    for (let i = 1; i < segs.length; i += 2) {\n      segs[i] = EmbraceGet.make(segs[i].trim()) ?? `{{${segs[i]}}}`;\n      if (!(segs[i] instanceof EmbraceGet))\n        console.error(`invalid embrace expression: ${segs[i]}`);//todo throw error in the EmbraceExp\n    }\n    return new EmbraceTextNode(segs);\n  }\n}\n\nclass EmbraceCommentFor {\n  constructor(templ, dollarName, listName) {\n    this.listName = listName;\n    this.dollarName = dollarName;\n    this.d = `$${dollarName}`;\n    this.dd = `$$${dollarName}`;\n    this.templ = templ.content;\n    templ.remove(); //remove the template from the Dom.\n    this.cube = new LoopCube(EmbraceRoot.make(this.templ));\n  }\n\n  get params() {\n    return { [this.listName]: this.listName };\n  }\n\n  run(argsDictionary, dataObject, node, ancestor) {\n    const now = argsDictionary[this.listName];\n    const { embraces, removes, changed } = this.cube.step(now);\n    for (let n of removes)\n      for (let c of n.nodes) //todo make a prop list on the EmbraceRoot to get all the childNodes only.\n        if (!(c instanceof Attr))\n          c.remove();\n    node.after(...embraces.map(e => e.template));\n    for (let i of changed) {\n      debugger;\n      dataObject[this.d] = now[i];\n      dataObject[this.dd] = i;\n      embraces[i].run(Object.assign({}, argsDictionary), dataObject, undefined, ancestor);\n    }\n  }\n\n  //naive, no nested control structures yet. no if. no switch. etc. , untested against errors.\n  //startUpTime\n  static make(txt, tmpl) {\n    const ctrlFor = txt.match(/{{\\s*for\\s*\\(\\s*([^\\s]+)\\s+of\\s+([^\\s)]+)\\)\\s*}}/);\n    if (ctrlFor) {\n      const [_, dollarName, listName] = ctrlFor;\n      return new EmbraceCommentFor(tmpl, dollarName, listName);\n    }\n  }\n}\n\nclass DomBranch {\n\n  static COMMENT_START = /{{\\s*(for|if).*}}/;\n  static COMMENT_END = /{{\\s*end\\s*}}/;\n\n  // static make(docFrag) {\n  //   DomBranch.subsume(docFrag);\n  //   return new DomBranch(docFrag);\n  // }\n\n  static flatDomNodesAll(docFrag) {\n    const res = [];\n    const it = document.createNodeIterator(docFrag, NodeFilter.SHOW_ALL);\n    for (let n; n = it.nextNode();) {\n      res.push(n);\n      if (n instanceof Element)\n        for (let a of n.attributes)\n          res.push(a);\n    }\n    return res;\n  }\n\n  static gobble(commentStart) {\n    const template = document.createElement(\"template\");\n    // commentStart.content = document.createDocumentFragment();\n    let n = commentStart.nextSibling;\n    while (n) {\n      if (n instanceof Comment) {\n        if (n.textContent.match(DomBranch.COMMENT_END))\n          return;\n        if (n.textContent.match(DomBranch.COMMENT_START))\n          DomBranch.gobble(n);\n      }\n      const m = n;\n      n = n.nextSibling;\n      template.content.append(m);\n    }\n    commentStart.after(template);\n    debugger;\n    DomBranch.subsume(template.content);\n  }\n\n  static subsume(n) {\n    function nextUp(n) {\n      while (n = n.parentNode)\n        if (n.nextSibling)\n          return n.nextSibling;\n    }\n    for (; n; n = n.firstChild ?? n.nextSibling ?? nextUp(n))\n      if (n instanceof Comment)\n        if (n.textContent.match(DomBranch.COMMENT_START))\n          DomBranch.gobble(n);\n  }\n}\n\nclass EmbraceRoot {\n\n  static paramDict(listOfExpressions) {\n    const params = {};\n    for (let e of listOfExpressions.filter(Boolean))\n      for (let p in e.params)\n        params[p] ??= p.split(\".\");\n    return params;\n  }\n\n  static listOfExpressions(listOfNodes) {\n    return listOfNodes.map(n => {\n      if (n instanceof Text || n instanceof Attr)\n        return EmbraceTextNode.make(n.textContent);\n      if (n instanceof Comment)\n        return EmbraceCommentFor.make(n.textContent, n.nextSibling);\n    });\n  }\n\n  constructor(docFrag) {\n    this.template = docFrag;\n    this.nodes = DomBranch.flatDomNodesAll(docFrag);\n  }\n\n  clone() {\n    const e = new EmbraceRoot(this.template.cloneNode(true));\n    e.expressions = this.expressions;\n    e.paramsDict = this.paramsDict;\n    return e;\n  }\n\n  run(argsDictionary, dataObject, _, ancestor) {\n    //1. make the argumentsDictionary\n    for (let param in this.paramsDict)\n      argsDictionary[param] ??= this.paramsDict[param].reduce((o, p) => o?.[p], dataObject);\n    //2. prep and run rules\n    for (let ex, n, i = 0; i < this.expressions.length; i++)\n      if (ex = this.expressions[i])\n        if (n = this.nodes[i])\n          if (n instanceof Attr ? ancestor.contains(n.ownerElement) : ancestor.contains(n))\n            ex.run(argsDictionary, dataObject, n, ancestor);\n  }\n\n  static make(docFrag) {\n    // DomBranch.subsume(docFrag);\n    const e = new EmbraceRoot(docFrag);\n    e.expressions = EmbraceRoot.listOfExpressions(e.nodes);\n    e.paramsDict = EmbraceRoot.paramDict(e.expressions);\n    return e;\n  }\n}\n\nexport function embrace(templ, dataObject) {\n  if (!this.__embraceRoot) {\n    DomBranch.subsume(templ); \n    //this runs recursively once at the start.\n    //todo we should move this operation into _t:\n    this.__embraceRoot = EmbraceRoot.make(templ);\n    this.ownerElement.append(this.__embraceRoot.template);\n  }\n  this.__embraceRoot.run({}, dataObject, 0, this.ownerElement);\n}", "const scopes = {\n  \".\": \"this.\",\n  \"e.\": \"window.eventLoop.event.\",\n  \"t.\": \"window.eventLoop.event.target.\",\n  \"w.\": \"window.\",\n  \"d.\": \"window.document.\",\n  // \"i.\": \"args[0].\",  //todo implement this instead of .oi\n  // \"i(0-9)+\": \"args[$1].\",//todo implement this instead of .oi\n  \"oi.\": \"oi.\",\n  \"at.\": \"window.eventLoop.attribute.\", //useful when dash rules have moved the origin\n  \"el.\": \"window.eventLoop.attribute.ownerElement.\", //todo same as this.ownerElement??\n  \"this.\": \"this.\",\n  \"window.\": \"window.\",\n  \"document.\": \"document.\"\n};\n\n//todo must rename oi to i, because of the change of structures.\nfunction processRef(prop) {\n  for (let prefix in scopes)\n    if (prop.startsWith(prefix))\n      return DoubleDots.kebabToPascal(scopes[prefix] + prop.slice(prefix.length));\n}\n\nconst primitives =\n  /^((-?\\d+(\\.\\d+)?([eE][-+]?\\d+)?)|this|window|document|i|e|true|false|undefined|null)$/;\n\nfunction textToExp(txt) {\n  let [prop, ...args] = txt.split(\"_\");\n  const ref = processRef(prop);\n  args = args.map(arg => processRef(arg) || primitives.test(arg) ? arg : `\"${arg}\"`);\n  const sargs = args.join(\", \");\n  const setter = !args.length ? \"\" : args.length === 1 ? `=${sargs}` : `=[${sargs}]`;\n  return `(${ref} instanceof Function ? ${ref}(${sargs}) : (${ref}${setter}))`;\n}\n\nfunction DotReactionRule(fullname) {\n  const exp = textToExp(fullname);\n  const code = `function dotReaction(oi) { return ${exp}; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//basic filters\nfunction BreakOnFalseReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} || EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\nfunction BreakOnTrueReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} && EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//jump\nfunction JumpReactionRule(fullname) {\n  const n = parseInt(fullname.slice(2));\n  if (!n || isNaN(n))\n    throw new DoubleDots.SyntaxError(\"ReactionJump only accept positive and negative integers: \" + fullname.slice(2));\n  // return _ => new EventLoop.ReactionJump(n);\n  return DoubleDots.importBasedEval(`_ => new EventLoop.ReactionJump(${n})`);\n}\n\nconst dynamicDots = {};\nfor (let prefix in scopes)\n  dynamicDots[prefix] = DotReactionRule;\ndynamicDots[\"x.\"] = BreakOnFalseReactionRule;\ndynamicDots[\"y.\"] = BreakOnTrueReactionRule;\ndynamicDots[\"j.\"] = JumpReactionRule;\n\nexport { dynamicDots as dynamicsDots };", "class ER {\n  constructor(posts) {\n    this.posts = posts;\n  }\n\n  * parents(ref, type, prop) {\n    for (let [k, v] of Object.entries(this.posts))\n      if (!type || k.startsWith(type))\n        if (prop && Array.isArray(v[prop]) && v[prop].includes(ref))\n          yield k;\n  }\n\n  parent(ref, type, prop) {\n    return this.parents(ref, type, prop).next().value;\n  }\n\n  //todo this can loop forever, when we have a person with a friend \n  //     that has a friend that is the first person. This won't work.\n  //\n  //todo 1. we need to go width first.\n  //todo 2. we need to check the path. If we are going from:\n  //        person / [friends] / person / [friends]\n  //        then we need to stop at the 2nd [friends].\n  //        we should only resolve person[friends] relationship *once*.\n  //        when we meet person[friends] 2nd time, we should just skip it.\n  //        this means that when we meet \"person\" the second time, \n  //        we should skip all the arrays.\n  resolve(key, vars) {\n    const res = Object.assign({}, vars, this.posts[key]);\n    for (let p in res)\n      if (res[p] instanceof Array)\n        res[p] = res[p].map(k => this.resolve(k, vars));\n    return res;\n  }\n}\n\nlet triggers = new DoubleDots.AttrWeakSet();\n\nexport class Er extends AttrCustom {\n  upgrade() {\n    triggers.add(this);\n  }\n}\n\nclass ErEvent extends Event {\n  constructor(type, er) {\n    super(type);\n    this.er = new ER(er);\n  }\n}\n\nexport function er(posts) {\n  eventLoop.dispatchBatch(new ErEvent(\"er\", posts), triggers);\n}", "export async function fetch_json() {\n  return (await fetch(this.value)).json();\n}\nexport async function fetch_text() {\n  return (await fetch(this.value)).text();\n}", "class AttributeIterator {\n\n  constructor(root, Type = Attr) {\n    this.elIt = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);\n    this.Type = Type;\n    this.attr = undefined;\n    this.nextElement();\n  }\n\n  nextElement() {\n    this.el = this.elIt.nextNode();\n    this.i = 0;\n    this.attributes = this.el ? Array.from(this.el.attributes) : [];\n  }\n\n  next() {\n    while (this.el?.isConnected) {\n      while (this.i < this.attributes.length) {\n        this.attr = this.attributes[this.i++];\n        if (this.attr.ownerElement)          //skip removed attributes\n          if (this.attr instanceof this.Type)//if Type===Attr, then no filter\n            return { value: this.attr, done: false };\n      }\n      this.nextElement();\n    }\n    this.attr = undefined;\n    return { done: true };\n  }\n\n  [Symbol.iterator]() { return this; }\n}\n\nclass PpIterator extends AttributeIterator {\n  constructor(root, Type = Attr) {\n    super(root, Type);\n    this.stack = [];\n  }\n  next() {\n    const i = super.next();\n    if (i.done) return i;\n    while (this.stack.length && !this.stack[0].el.contains(this.el))\n      this.stack.shift();\n    const pathEl = this.makePath(i.value, this.stack[0]?.path);\n    this.stack.unshift(pathEl);\n    return i;\n  }\n\n  makePath({ ownerElement: el, value: path }, parentPath = []) {\n    path = path.split(\".\");\n    path = path[0] ? path : [...parentPath, ...path.slice(1)];\n    return { el, path };\n  }\n\n  get currentPath() {\n    return this.stack[0].path;\n  }\n}\n\nfunction findNearestPpObject(el) {\n  for (; el; el = el.parentElement)\n    if (el.pp)\n      return el.pp;\n}\n\nclass PpEvent extends Event {\n  constructor(type, root, IT) {\n    super(type);\n    this.IT = IT;\n    this.root = root;\n  }\n\n  //return IT.currentPath.reduce((o, p) => o?.[p], this.root);\n  get [Event.data]() {\n    let v = this.root;\n    let k;\n    for (k of IT.currentPath)\n      v = v?.[k];\n    return v instanceof Object ?\n      Object.assign({ \"#key\": k }, v) :\n      { \"#key\": k, \"#value\": v };\n  }\n}\n\nfunction propagate(scope, pp) {\n  IT = new PpIterator(scope, Pp);\n  eventLoop.dispatchBatch(new PpEvent(\"pp\", pp, IT), IT);\n}\n\nlet IT;\n\nexport function pp(obj) {\n  if (IT?.attr)\n    throw new Error(\":pp reaction cannot be triggered while the pp: is propagating\");\n  this.ownerElement.pp = obj;\n  obj && propagate(this.ownerElement, obj);\n}\n\nexport class Pp extends AttrCustom {\n  upgrade() {\n    for (let a of this.ownerElement.attributes)\n      if (a !== this && a instanceof Pp)\n        throw new Error(\"An element can only hold one \" + this.trigger + \":\");\n  }\n  set value(v) {\n    super.value = v;\n    if (IT?.attr) {\n      if (IT.attr === this)\n        throw new Error(\"reactions on pp: trigger cannot change their own value!\");\n      if (!IT.attr.ownerElement.contains(this.ownerElement))\n        throw new Error(\"pp: mutation outside scope: \" + IT.attr.ownerElement + \" >! \" + this.ownerElement);\n      return;\n    }\n    const pp = findNearestPpObject(this.ownerElement);\n    pp && propagate(this.ownerElement, pp);\n  }\n  get value() { return super.value; }\n}\n\nfunction loopTask(template, key, triggerName) {\n  const clone = template.cloneNode(true);\n  for (let c of clone.children)\n    for (let a of c.attributes)\n      if (a.name.startsWith(triggerName))\n        return (a.value = \".\" + key), clone;\n  return clone;\n}\n\n//In objects, properties starting with \"#\" such as \n//\"#key\" or \"#private\" will be excluded by the :loop.\nexport function loop(template, now) {\n  if (!(template instanceof DocumentFragment) || !template.children.length)\n    throw new Error(\"loop #1 argument must be a DocumentFragment with at least one child element.\");\n  if (typeof now !== 'object')\n    throw new Error(\"loop #2 argument is not an object.\");\n  const trigger = this.trigger + \":\";\n  this.ownerElement.textContent = \"\";\n  const keys = now instanceof Array ?\n    now.map((_, i) => i) :\n    Object.keys(now).filter(p => !p.startsWith(\"#\"));\n  for (let key of keys)\n    this.ownerElement.append(...loopTask(template, key, trigger).childNodes);\n  return now;\n}\n\n//Optimization attemps. Skipped for now.\n\nclass LoopCube {\n  static compareSmall(old, now) {\n    const exact = new Array(now.length);\n    const unused = [];\n    if (!old?.length)\n      return { exact, unused };\n    main: for (let o = 0; o < old.length; o++) {\n      for (let n = 0; n < now.length; n++) {\n        if (!exact[n] && old[o] === now[n]) {\n          exact[n] = o;\n          continue main;\n        }\n      }\n      unused.push(o);\n    }\n    return { exact, unused };\n  }\n\n  constructor(root, template) {\n    this.root = root;\n    this.template = template;\n    this.tl = template.childNodes.length;\n    this.now = [];\n    this.root.textContent = \"\";\n  }\n\n  getTemplClone() {\n    return this.template.cloneNode(true).childNodes;\n  }\n\n  moveToRes(n, o, now, old, scale) {\n    n *= scale;\n    o *= scale;\n    for (let i = 0; i < scale; i++)\n      now[n + i] = old[o + i];\n  }\n\n  step(now = []) {\n    const old = this.now;\n    this.now = now;\n    const { exact, unused } = LoopCube.compareSmall(old, now);\n\n    const oldNodes = this.root.childNodes;\n    const nowNodes = new Array(now.length * this.tl);\n    for (let n = 0; n < exact.length; n++) {\n      const o = exact[n];\n      if (o != null) {\n        this.moveToRes(n, o, nowNodes, oldNodes, this.tl);\n      } else {\n        unused.length ?\n          this.moveToRes(n, unused.pop(), nowNodes, oldNodes, this.tl) :\n          this.moveToRes(n, 0, nowNodes, this.getTemplClone(), this.tl);\n        this.task(nowNodes, n);\n      }\n    }\n    const removeNodes = [];\n    for (let u = unused.pop(), i = 0; u != null; i++, u = unused.pop())\n      this.moveToRes(i, u, removeNodes, oldNodes, this.tl);\n    return nowNodes;\n  }\n\n  task(i) { }\n}\n\nclass LoopCubeAttr extends LoopCube {\n  constructor(attr, template) {\n    super(attr.ownerElement, template);\n    this.attr = attr;\n    this.triggerName = attr.trigger + \":\";\n  }\n\n  task(nowNodes, i) {\n    for (let j = 0, start = i * this.tl; j < this.tl; j++)\n      if (nowNodes[start + j].attributes)\n        for (let a of nowNodes[start + j].attributes)\n          if (a.name.startsWith(this.triggerName))\n            return a.value = \".\" + i;\n  }\n}\n\nfunction loopOptimal(template, now) {\n  const triggerName = \"pp\";\n  if (!Array.isArray(now))\n    throw new Error(\"loop #2 argument is not an array.\");\n  if (!(template instanceof DocumentFragment) || !template.children.length)\n    throw new Error(\"loop #1 argument must be a DocumentFragment with at least one child element.\");\n  const res = (this.__loop ??= new LoopCubeAttr(this, template)).step(now);\n  res.length ? this.ownerElement.append(...res) : this.ownerElement.innerText = \"\";\n  return now;\n}", "export class WindowTrigger extends AttrListener {\n  get target() { return window; }\n}\n\nexport class DocumentTrigger extends AttrListener {\n  get target() { return document; }\n}\n\nexport class DCLTrigger extends DocumentTrigger {\n  get type() { return \"DOMContentLoaded\"; }\n}\n\nexport class PrePropTrigger extends WindowTrigger { //global _click\n  get type() { return this.trigger.slice(1); } //remove prefix so returns \"click\"\n  get options() { return true; }\n}\n\nexport class PostPropTrigger extends WindowTrigger { //global click_\n  get type() { return this.trigger.slice(-1); } //remove postfix so returns \"click\"\n}\n\nfunction makeAll() {\n  const upCase = s => s[0].toUpperCase() + s.slice(1);\n  const res = {};\n  for (let type of DoubleDots.nativeEvents.element) {\n    type = upCase(type);\n    res[type] = AttrListener;\n    res[\"_\" + type] = PrePropTrigger;\n    res[type + \"_\"] = PostPropTrigger;\n  }\n  for (let type of DoubleDots.nativeEvents.window)\n    res[upCase(type)] = WindowTrigger;\n  for (let type of DoubleDots.nativeEvents.document)\n    res[upCase(type)] = DocumentTrigger;\n  delete res[\"DOMContentLoaded\"];\n  res[\"Domcontentloaded\"] = DCLTrigger;\n  return res;\n}\nexport const dynamicSimpleProp = makeAll();\n\n/**\n# SimplePropagation\n\n>> Note!! You must register the triggers for `custom-event`s too, such as `document.Triggers.define(\"custom-event\", AttrListener);`.\n\nIn HTML events \"propagate\" in the DOM. These events are small data messages that trigger reactions in the form of JS event listener functions.\n\n## Propagation triggers\n\nIn DoubleDots events also propagate in the DOM. DoubleDots use propagation triggers to react to them. For example `click:toggle_open` uses a `click` propagation trigger to react to `click` event and invoke the `:toggle_open` reaction chain.\n\n## `AttrListener`\n\nThe `AttrListener` is a special subtype of `AttrCustom` that handle native event listeners. Most commonly you will only import a set of propagation triggers for native events, and maybe add some of the propagation triggers to your own `custom-event` types. Most DoubleDots environments will deprecate the native event listeners and only allow event listeners to react to propagation triggers that `extends AttrListener`. Both for native events and custom events. \n\n## HowTo: use `custom-event`s in this SimplePropagation setup?\n\nTo `dispatch` and listen for a `custom-event` using SimplePropagation, \nyou must first and only register their triggers:\n\n1. If you only wish to have normal bubble triggers for them, you only register their bubble triggers.\n```js\n  document.Triggers.define(\"custom-event\", AttrListener);  \n```\n\n2. If you wish the event to be a global, you register it as a WindowTrigger.\n```js\n  document.Triggers.define(\"custom-global-event\", WindowTrigger);  \n```\n3. If you wish the event to be global, and you want to use pre- and post-propagation triggers, register all needed triggers.\n```js\n    document.Triggers.define(\"custom-event\", AttrListener);\n    document.Triggers.define(\"_custom-event\", PrePropTrigger);\n    document.Triggers.define(\"custom-event_\", PostPropTrigger);\n```\n\n## DefaultActions, `stopPropagation()` and SimplePropagation\n\nThe SimplePropagation setup enables you to use native default actions normally.\nThis means that you can call `e.preventDefault()` within any reaction chain for that event.\n\nDoubleDots recommend *against* using `e.stopPropagation()` and `e.stopImmediatePropagation()`. But when you use SimplePropagation, you can allow stopPropagation().\n\n## HowTo: `extends AttrListener`\n\nIf you need to implement your own propagation triggers, the `AttrListener` provide the following interface:\n1. `get target()` (default: `this.ownerElement`)\n2. `get type()` (default: `this.trigger`)\n3. `get options()` (default: undefined)\n4. `run(e){...}` (default: `eventLoop.dispatch(e, this)`)\n\n## Performance and consistency\n\nSimplePropagation follows the same logic as native event listeners. This means that:\n1. listeners/triggers can always be removed. This makes sense.\n2. But, *sometimes* listeners can be added and triggered during the same event propagation cycle, *sometimes* not. Listeners added later in the propagation cycle will be triggered, except when they are on the same element in the same phase as the current element.\n3. The sync/async behavior can be confusing, as sometimes each event listener is given its own macro task, sometimes all event listeners are considered *one* macro task, and sometimes the event listeners are considered sync (when dispatched via `dispatchEvent`).\n\nThe overhead per native event listener is not that big. It is quite performant. The only cost is resolving the reaction chain and maintaining the eventLoop state.\n\n## `Event.activeListeners()`\n\nThe AttrListener keeps track of how many listener are active for any event type at any time. Asking `Event.activeListeners(\"click\")` will return the number of active `click` event listeners in the DOM. This method can be used to for example:\n\n1. debug an app to see what it does,\n\n2. to throw error if `dispatchEvent` is called for an event no one is listening for:\n\n```js\nEventTarget.prototype.dispatchEvent(e){\n  if(Event.activeListeners(e.type))\n    throw new DoubleDots.PropagationError(`dispatching event \"${e.type}\" when no one is listening.`);\n  OG.call(this, e);\n}\n```\n*/", "//todo trim the template to remove ws text nodes before and after the template??\nfunction getHoistTemplate(el, name) {\n  name ||= el.tagName.toLowerCase();\n  let res = document.head.querySelector(`template[name=\"${name}\"]`);\n  if (res)\n    return res.content;\n  el = el.firstElementChild;\n  if (!(el instanceof HTMLTemplateElement))\n    return;\n  el.setAttribute(\"name\", name);\n  document.head.append(el);\n  return el.content;\n}\n\nexport function template_(rule) {\n  let [_, name] = rule.split(\"_\");\n  return function template() {\n    return this.__template ??= getHoistTemplate(this.ownerElement, name);\n  };\n}\n\n//todo untested\nexport function template() {\n  return this.__template ??= getHoistTemplate(this.ownerElement, this.ownerElement.getAttribute(\"template\"));\n};\n\n//todo the template_attr_val_attr2_val2... rule. The .val are interpreted as dotGetters.\n//todo tag-name is always ownerElement.tagName\n//todo other empty values are attempted replaced with the value of \n//todo a prop of the incoming data element. Again, this will work if \n//todo the incoming element is not an Event, but just the data object. \n//todo This means that we need to filter the value.\n//todo if no value, then the attribute is just checked for presence.\n//todo the \"if/else\" of works by selecting a template based on the value from first argument.\n\n//:template_type_.post.type       => <template type=\"${post.type}\">\n//:template_name_hellosunshine    => <template name=\"hellosunshine\">\n//:template_tag-name              => <template tag-name=\"my-component\">\n//:template                       => ownerElement.firstChild template.\n\n//the rules inside the brace don't allow us to \n//remove any nodes from the branch dynamically.\n//if we do, then the rules will run against the wrong node."],
  "mappings": "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",
  "names": ["dotPathGet", "dotPath", "obj", "p", "processBraces", "txt", "post", "_", "expr", "bodyTasks", "el", "triggerName", "ii", "a", "name", "value", "n", "now", "e", "i", "brace", "cb", "LoopCube", "old", "now", "exact", "unused", "main", "n", "embrace", "oldEmbraces", "embraces", "changed", "o", "removes", "EmbraceGet", "param", "argsDict", "dataIn", "node", "ancestor", "str", "EmbraceTextNode", "segs", "res", "E", "txt", "s", "i", "EmbraceCommentFor", "templ", "dollarName", "listName", "EmbraceRoot", "argsDictionary", "dataObject", "c", "e", "tmpl", "ctrlFor", "_", "_DomBranch", "docFrag", "it", "a", "commentStart", "template", "m", "nextUp", "DomBranch", "__publicField", "listOfExpressions", "params", "p", "listOfNodes", "ex", "scopes", "processRef", "prop", "prefix", "primitives", "textToExp", "txt", "args", "ref", "arg", "sargs", "setter", "DotReactionRule", "fullname", "code", "BreakOnFalseReactionRule", "BreakOnTrueReactionRule", "JumpReactionRule", "n", "dynamicDots", "ER", "posts", "ref", "type", "prop", "k", "v", "key", "vars", "res", "p", "triggers", "Er", "ErEvent", "er", "fetch_json", "fetch_text", "AttributeIterator", "root", "Type", "PpIterator", "i", "pathEl", "el", "path", "parentPath", "findNearestPpObject", "PpEvent", "type", "IT", "v", "k", "propagate", "scope", "pp", "Pp", "obj", "a", "loopTask", "template", "key", "triggerName", "clone", "c", "loop", "now", "trigger", "keys", "_", "p", "LoopCube", "old", "exact", "unused", "main", "n", "o", "scale", "oldNodes", "nowNodes", "removeNodes", "u", "LoopCubeAttr", "attr", "j", "start", "loopOptimal", "res", "WindowTrigger", "DocumentTrigger", "DCLTrigger", "PrePropTrigger", "PostPropTrigger", "makeAll", "upCase", "s", "res", "type", "dynamicSimpleProp", "getHoistTemplate", "el", "name", "res", "template_", "rule", "_", "template"]
}
