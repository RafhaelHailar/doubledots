{
  "version": 3,
  "sources": ["x/brace/v1.js", "x/dotRule/dot.js", "x/er/v1.js", "x/fetch/v1.js", "x/pp/v1.js", "x/PropagationSimple/prop.js", "x/template/v1.js"],
  "sourcesContent": ["function dotPathGet(dotPath, obj) {\n  if (dotPath === \".\")\n    return obj;\n  for (let p of dotPath.split(\".\"))\n    if (!(obj = obj?.[p]))\n      return obj === 0 ? obj : \"\";\n  return obj;\n}\n\nfunction processBraces(txt, post) {\n  return txt.replace(/\\{\\{([^}{]+)\\}\\}/g, (_, expr) => dotPathGet(expr, post));\n}\n\nfunction* bodyTasks(el, triggerName, ii = []) {\n  if (el instanceof Element) {\n    if (ii.length) //skip during first check\n      for (let a of el.attributes)\n        if (a.name.startsWith(triggerName))\n          return;\n    for (let { name, value } of el.attributes)\n      if (value.indexOf(\"{{\") >= 0)\n        yield (n, now) => ii.reduce((e, i) => e.childNodes[i], n).setAttribute(name, processBraces(value, now));\n    for (let i = 0; i < el.childNodes.length; i++)\n      yield* bodyTasks(el.childNodes[i], triggerName, [...ii, i]);\n  } else if (el instanceof Text) {\n    const txt = el.textContent;\n    if (txt.indexOf(\"{{\") >= 0)\n      yield (n, now) => ii.reduce((e, i) => e.childNodes[i], n).textContent = processBraces(txt, now);\n  }\n}\n\nexport function brace(now) {\n  this.__tasks ??= [...bodyTasks(this.ownerElement, this.trigger + \":\")];\n  for (let cb of this.__tasks)\n    cb(this.ownerElement, now);\n  return now;\n}", "const scopes = {\n  \".\": \"this.\",\n  \"e.\": \"window.eventLoop.event.\",\n  \"t.\": \"window.eventLoop.event.target.\",\n  \"w.\": \"window.\",\n  \"d.\": \"window.document.\",\n  // \"i.\": \"args[0].\",  //todo implement this instead of .oi\n  // \"i(0-9)+\": \"args[$1].\",//todo implement this instead of .oi\n  \"oi.\": \"oi.\",\n  \"at.\": \"window.eventLoop.attribute.\", //useful when dash rules have moved the origin\n  \"el.\": \"window.eventLoop.attribute.ownerElement.\", //todo same as this.ownerElement??\n  \"this.\": \"this.\",\n  \"window.\": \"window.\",\n  \"document.\": \"document.\"\n};\n\n//todo must rename oi to i, because of the change of structures.\nfunction processRef(prop) {\n  for (let prefix in scopes)\n    if (prop.startsWith(prefix))\n      return DoubleDots.kebabToPascal(scopes[prefix] + prop.slice(prefix.length));\n}\n\nconst primitives =\n  /^((-?\\d+(\\.\\d+)?([eE][-+]?\\d+)?)|this|window|document|i|e|true|false|undefined|null)$/;\n\nfunction textToExp(txt) {\n  let [prop, ...args] = txt.split(\"_\");\n  const ref = processRef(prop);\n  args = args.map(arg => processRef(arg) || primitives.test(arg) ? arg : `\"${arg}\"`);\n  const sargs = args.join(\", \");\n  const setter = !args.length ? \"\" : args.length === 1 ? `=${sargs}` : `=[${sargs}]`;\n  return `(${ref} instanceof Function ? ${ref}(${sargs}) : (${ref}${setter}))`;\n}\n\nfunction DotReactionRule(fullname) {\n  const exp = textToExp(fullname);\n  const code = `function dotReaction(oi) { return ${exp}; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//basic filters\nfunction BreakOnFalseReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} || EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\nfunction BreakOnTrueReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} && EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//jump\nfunction JumpReactionRule(fullname) {\n  const n = parseInt(fullname.slice(2));\n  if (!n || isNaN(n))\n    throw new DoubleDots.SyntaxError(\"ReactionJump only accept positive and negative integers: \" + fullname.slice(2));\n  // return _ => new EventLoop.ReactionJump(n);\n  return DoubleDots.importBasedEval(`_ => new EventLoop.ReactionJump(${n})`);\n}\n\nconst dynamicDots = {};\nfor (let prefix in scopes)\n  dynamicDots[prefix] = DotReactionRule;\ndynamicDots[\"x.\"] = BreakOnFalseReactionRule;\ndynamicDots[\"y.\"] = BreakOnTrueReactionRule;\ndynamicDots[\"j.\"] = JumpReactionRule;\n\nexport { dynamicDots as dynamicsDots };", "class ER {\n  constructor(posts) {\n    this.posts = posts;\n  }\n\n  * parents(ref, type, prop) {\n    for (let [k, v] of Object.entries(this.posts))\n      if (!type || k.startsWith(type))\n        if (prop && Array.isArray(v[prop]) && v[prop].includes(ref))\n          yield k;\n  }\n\n  parent(ref, type, prop) {\n    return this.parents(ref, type, prop).next().value;\n  }\n\n  //todo this can loop forever, when we have a person with a friend \n  //     that has a friend that is the first person. This won't work.\n  //\n  //todo 1. we need to go width first.\n  //todo 2. we need to check the path. If we are going from:\n  //        person / [friends] / person / [friends]\n  //        then we need to stop at the 2nd [friends].\n  //        we should only resolve person[friends] relationship *once*.\n  //        when we meet person[friends] 2nd time, we should just skip it.\n  //        this means that when we meet \"person\" the second time, \n  //        we should skip all the arrays.\n  resolve(key, vars) {\n    const res = Object.assign({}, vars, this.posts[key]);\n    for (let p in res)\n      if (res[p] instanceof Array)\n        res[p] = res[p].map(k => this.resolve(k, vars));\n    return res;\n  }\n}\n\nlet triggers = new DoubleDots.AttrWeakSet();\n\nexport class Er extends AttrCustom {\n  upgrade() {\n    triggers.add(this);\n  }\n}\n\nclass ErEvent extends Event {\n  constructor(type, er) {\n    super(type);\n    this.er = new ER(er);\n  }\n}\n\nexport function er(posts) {\n  eventLoop.dispatchBatch(new ErEvent(\"er\", posts), triggers);\n}", "export async function fetch_json() {\n  return (await fetch(this.value)).json();\n}\nexport async function fetch_text() {\n  return (await fetch(this.value)).text();\n}", "class AttributeIterator {\n\n  constructor(root, Type = Attr) {\n    this.elIt = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);\n    this.Type = Type;\n    this.attr = undefined;\n    this.nextElement();\n  }\n\n  nextElement() {\n    this.el = this.elIt.nextNode();\n    this.i = 0;\n    this.attributes = this.el ? Array.from(this.el.attributes) : [];\n  }\n\n  next() {\n    while (this.el?.isConnected) {\n      while (this.i < this.attributes.length) {\n        this.attr = this.attributes[this.i++];\n        if (this.attr.ownerElement)          //skip removed attributes\n          if (this.attr instanceof this.Type)//if Type===Attr, then no filter\n            return { value: this.attr, done: false };\n      }\n      this.nextElement();\n    }\n    this.attr = undefined;\n    return { done: true };\n  }\n\n  [Symbol.iterator]() { return this; }\n}\n\nclass PpIterator extends AttributeIterator {\n  constructor(root, Type = Attr) {\n    super(root, Type);\n    this.stack = [];\n  }\n  next() {\n    const i = super.next();\n    if (i.done) return i;\n    while (this.stack.length && !this.stack[0].el.contains(this.el))\n      this.stack.shift();\n    const pathEl = this.makePath(i.value, this.stack[0]?.path);\n    this.stack.unshift(pathEl);\n    return i;\n  }\n\n  makePath({ ownerElement: el, value: path }, parentPath = []) {\n    path = path.split(\".\");\n    path = path[0] ? path : [...parentPath, ...path.slice(1)];\n    return { el, path };\n  }\n\n  get currentPath() {\n    return this.stack[0].path;\n  }\n}\n\nfunction findNearestPpObject(el) {\n  for (; el; el = el.parentElement)\n    if (el.pp)\n      return el.pp;\n}\n\nclass PpEvent extends Event {\n  constructor(type, root, IT) {\n    super(type);\n    this.IT = IT;\n    this.root = root;\n  }\n\n  //return IT.currentPath.reduce((o, p) => o?.[p], this.root);\n  get [Event.data]() {\n    let v = this.root;\n    let k;\n    for (k of IT.currentPath)\n      v = v?.[k];\n    return v instanceof Object ?\n      Object.assign({ \"#key\": k }, v) :\n      { \"#key\": k, \"#value\": v };\n  }\n}\n\nfunction propagate(scope, pp) {\n  IT = new PpIterator(scope, Pp);\n  eventLoop.dispatchBatch(new PpEvent(\"pp\", pp, IT), IT);\n}\n\nlet IT;\n\nexport function pp(obj) {\n  if (IT?.attr)\n    throw new Error(\":pp reaction cannot be triggered while the pp: is propagating\");\n  this.ownerElement.pp = obj;\n  obj && propagate(this.ownerElement, obj);\n}\n\nexport class Pp extends AttrCustom {\n  upgrade() {\n    for (let a of this.ownerElement.attributes)\n      if (a !== this && a instanceof Pp)\n        throw new Error(\"An element can only hold one \" + this.trigger + \":\");\n  }\n  set value(v) {\n    super.value = v;\n    if (IT?.attr) {\n      if (IT.attr === this)\n        throw new Error(\"reactions on pp: trigger cannot change their own value!\");\n      if (!IT.attr.ownerElement.contains(this.ownerElement))\n        throw new Error(\"pp: mutation outside scope: \" + IT.attr.ownerElement + \" >! \" + this.ownerElement);\n      return;\n    }\n    const pp = findNearestPpObject(this.ownerElement);\n    pp && propagate(this.ownerElement, pp);\n  }\n  get value() { return super.value; }\n}\n\nfunction loopTask(template, key, triggerName) {\n  const clone = template.cloneNode(true);\n  for (let c of clone.children)\n    for (let a of c.attributes)\n      if (a.name.startsWith(triggerName))\n        return (a.value = \".\" + key), clone;\n  return clone;\n}\n\n//In objects, properties starting with \"#\" such as \n//\"#key\" or \"#private\" will be excluded by the :loop.\nexport function loop(template, now) {\n  if (!(template instanceof DocumentFragment) || !template.children.length)\n    throw new Error(\"loop #1 argument must be a DocumentFragment with at least one child element.\");\n  if (typeof now !== 'object')\n    throw new Error(\"loop #2 argument is not an object.\");\n  const trigger = this.trigger + \":\";\n  this.ownerElement.textContent = \"\";\n  const keys = now instanceof Array ?\n    now.map((_, i) => i) :\n    Object.keys(now).filter(p => !p.startsWith(\"#\"));\n  for (let key of keys)\n    this.ownerElement.append(...loopTask(template, key, trigger).childNodes);\n  return now;\n}\n\n//Optimization attemps. Skipped for now.\n\nclass LoopCube {\n  static compareSmall(old, now) {\n    const exact = new Array(now.length);\n    const unused = [];\n    if (!old?.length)\n      return { exact, unused };\n    main: for (let o = 0; o < old.length; o++) {\n      for (let n = 0; n < now.length; n++) {\n        if (!exact[n] && old[o] === now[n]) {\n          exact[n] = o;\n          continue main;\n        }\n      }\n      unused.push(o);\n    }\n    return { exact, unused };\n  }\n\n  constructor(root, template) {\n    this.root = root;\n    this.template = template;\n    this.tl = template.childNodes.length;\n    this.now = [];\n    this.root.textContent = \"\";\n  }\n\n  getTemplClone() {\n    return this.template.cloneNode(true).childNodes;\n  }\n\n  moveToRes(n, o, now, old, scale) {\n    n *= scale;\n    o *= scale;\n    for (let i = 0; i < scale; i++)\n      now[n + i] = old[o + i];\n  }\n\n  step(now = []) {\n    const old = this.now;\n    this.now = now;\n    const { exact, unused } = LoopCube.compareSmall(old, now);\n\n    const oldNodes = this.root.childNodes;\n    const nowNodes = new Array(now.length * this.tl);\n    for (let n = 0; n < exact.length; n++) {\n      const o = exact[n];\n      if (o != null) {\n        this.moveToRes(n, o, nowNodes, oldNodes, this.tl);\n      } else {\n        unused.length ?\n          this.moveToRes(n, unused.pop(), nowNodes, oldNodes, this.tl) :\n          this.moveToRes(n, 0, nowNodes, this.getTemplClone(), this.tl);\n        this.task(nowNodes, n);\n      }\n    }\n    const removeNodes = [];\n    for (let u = unused.pop(), i = 0; u != null; i++, u = unused.pop())\n      this.moveToRes(i, u, removeNodes, oldNodes, this.tl);\n    return nowNodes;\n  }\n\n  task(i) { }\n}\n\nclass LoopCubeAttr extends LoopCube {\n  constructor(attr, template) {\n    super(attr.ownerElement, template);\n    this.attr = attr;\n    this.triggerName = attr.trigger + \":\";\n  }\n\n  task(nowNodes, i) {\n    for (let j = 0, start = i * this.tl; j < this.tl; j++)\n      if (nowNodes[start + j].attributes)\n        for (let a of nowNodes[start + j].attributes)\n          if (a.name.startsWith(this.triggerName))\n            return a.value = \".\" + i;\n  }\n}\n\nfunction loopOptimal(template, now) {\n  const triggerName = \"pp\";\n  if (!Array.isArray(now))\n    throw new Error(\"loop #2 argument is not an array.\");\n  if (!(template instanceof DocumentFragment) || !template.children.length)\n    throw new Error(\"loop #1 argument must be a DocumentFragment with at least one child element.\");\n  const res = (this.__loop ??= new LoopCubeAttr(this, template)).step(now);\n  res.length ? this.ownerElement.append(...res) : this.ownerElement.innerText = \"\";\n  return now;\n}", "export class WindowTrigger extends AttrListener {\n  get target() { return window; }\n}\n\nexport class DocumentTrigger extends AttrListener {\n  get target() { return document; }\n}\n\nexport class DCLTrigger extends DocumentTrigger {\n  get type() { return \"DOMContentLoaded\"; }\n}\n\nexport class PrePropTrigger extends WindowTrigger { //global _click\n  get type() { return this.trigger.slice(1); } //remove prefix so returns \"click\"\n  get options() { return true; }\n}\n\nexport class PostPropTrigger extends WindowTrigger { //global click_\n  get type() { return this.trigger.slice(-1); } //remove postfix so returns \"click\"\n}\n\nfunction makeAll() {\n  const upCase = s => s[0].toUpperCase() + s.slice(1);\n  const res = {};\n  for (let type of DoubleDots.nativeEvents.element) {\n    type = upCase(type);\n    res[type] = AttrListener;\n    res[\"_\" + type] = PrePropTrigger;\n    res[type + \"_\"] = PostPropTrigger;\n  }\n  for (let type of DoubleDots.nativeEvents.window)\n    res[upCase(type)] = WindowTrigger;\n  for (let type of DoubleDots.nativeEvents.document)\n    res[upCase(type)] = DocumentTrigger;\n  delete res[\"DOMContentLoaded\"];\n  res[\"Domcontentloaded\"] = DCLTrigger;\n  return res;\n}\nexport const dynamicSimpleProp = makeAll();\n\n/**\n# SimplePropagation\n\n>> Note!! You must register the triggers for `custom-event`s too, such as `document.Triggers.define(\"custom-event\", AttrListener);`.\n\nIn HTML events \"propagate\" in the DOM. These events are small data messages that trigger reactions in the form of JS event listener functions.\n\n## Propagation triggers\n\nIn DoubleDots events also propagate in the DOM. DoubleDots use propagation triggers to react to them. For example `click:toggle_open` uses a `click` propagation trigger to react to `click` event and invoke the `:toggle_open` reaction chain.\n\n## `AttrListener`\n\nThe `AttrListener` is a special subtype of `AttrCustom` that handle native event listeners. Most commonly you will only import a set of propagation triggers for native events, and maybe add some of the propagation triggers to your own `custom-event` types. Most DoubleDots environments will deprecate the native event listeners and only allow event listeners to react to propagation triggers that `extends AttrListener`. Both for native events and custom events. \n\n## HowTo: use `custom-event`s in this SimplePropagation setup?\n\nTo `dispatch` and listen for a `custom-event` using SimplePropagation, \nyou must first and only register their triggers:\n\n1. If you only wish to have normal bubble triggers for them, you only register their bubble triggers.\n```js\n  document.Triggers.define(\"custom-event\", AttrListener);  \n```\n\n2. If you wish the event to be a global, you register it as a WindowTrigger.\n```js\n  document.Triggers.define(\"custom-global-event\", WindowTrigger);  \n```\n3. If you wish the event to be global, and you want to use pre- and post-propagation triggers, register all needed triggers.\n```js\n    document.Triggers.define(\"custom-event\", AttrListener);\n    document.Triggers.define(\"_custom-event\", PrePropTrigger);\n    document.Triggers.define(\"custom-event_\", PostPropTrigger);\n```\n\n## DefaultActions, `stopPropagation()` and SimplePropagation\n\nThe SimplePropagation setup enables you to use native default actions normally.\nThis means that you can call `e.preventDefault()` within any reaction chain for that event.\n\nDoubleDots recommend *against* using `e.stopPropagation()` and `e.stopImmediatePropagation()`. But when you use SimplePropagation, you can allow stopPropagation().\n\n## HowTo: `extends AttrListener`\n\nIf you need to implement your own propagation triggers, the `AttrListener` provide the following interface:\n1. `get target()` (default: `this.ownerElement`)\n2. `get type()` (default: `this.trigger`)\n3. `get options()` (default: undefined)\n4. `run(e){...}` (default: `eventLoop.dispatch(e, this)`)\n\n## Performance and consistency\n\nSimplePropagation follows the same logic as native event listeners. This means that:\n1. listeners/triggers can always be removed. This makes sense.\n2. But, *sometimes* listeners can be added and triggered during the same event propagation cycle, *sometimes* not. Listeners added later in the propagation cycle will be triggered, except when they are on the same element in the same phase as the current element.\n3. The sync/async behavior can be confusing, as sometimes each event listener is given its own macro task, sometimes all event listeners are considered *one* macro task, and sometimes the event listeners are considered sync (when dispatched via `dispatchEvent`).\n\nThe overhead per native event listener is not that big. It is quite performant. The only cost is resolving the reaction chain and maintaining the eventLoop state.\n\n## `Event.activeListeners()`\n\nThe AttrListener keeps track of how many listener are active for any event type at any time. Asking `Event.activeListeners(\"click\")` will return the number of active `click` event listeners in the DOM. This method can be used to for example:\n\n1. debug an app to see what it does,\n\n2. to throw error if `dispatchEvent` is called for an event no one is listening for:\n\n```js\nEventTarget.prototype.dispatchEvent(e){\n  if(Event.activeListeners(e.type))\n    throw new DoubleDots.PropagationError(`dispatching event \"${e.type}\" when no one is listening.`);\n  OG.call(this, e);\n}\n```\n*/", "//todo trim the template to remove ws text nodes before and after the template??\nfunction getHoistTemplate(el, name) {\n  name ||= el.tagName.toLowerCase();\n  let res = document.head.querySelector(`template[name=\"${name}\"]`);\n  if (res)\n    return res.content;\n  el = el.firstElementChild;\n  if (!(el instanceof HTMLTemplateElement))\n    return;\n  el.setAttribute(\"name\", name);\n  document.head.append(el);\n  return el.content;\n}\n\nexport function template_(rule) {\n  let [_, name] = rule.split(\"_\");\n  return function template() {\n    return this.__template ??= getHoistTemplate(this.ownerElement, name);\n  };\n}\n\n//todo untested\nexport function template() {\n  return this.__template ??= getHoistTemplate(this.ownerElement, this.ownerElement.getAttribute(\"template\"));\n};\n\n//todo the template_attr_val_attr2_val2... rule. The .val are interpreted as dotGetters.\n//todo tag-name is always ownerElement.tagName\n//todo other empty values are attempted replaced with the value of \n//todo a prop of the incoming data element. Again, this will work if \n//todo the incoming element is not an Event, but just the data object. \n//todo This means that we need to filter the value.\n//todo if no value, then the attribute is just checked for presence.\n//todo the \"if/else\" of works by selecting a template based on the value from first argument.\n\n//:template_type_.post.type       => <template type=\"${post.type}\">\n//:template_name_hellosunshine    => <template name=\"hellosunshine\">\n//:template_tag-name              => <template tag-name=\"my-component\">\n//:template                       => ownerElement.firstChild template.\n\n//the rules inside the brace don't allow us to \n//remove any nodes from the branch dynamically.\n//if we do, then the rules will run against the wrong node."],
  "mappings": "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",
  "names": ["dotPathGet", "dotPath", "obj", "p", "processBraces", "txt", "post", "_", "expr", "bodyTasks", "el", "triggerName", "ii", "a", "name", "value", "n", "now", "e", "i", "brace", "cb", "scopes", "processRef", "prop", "prefix", "primitives", "textToExp", "txt", "args", "ref", "arg", "sargs", "setter", "DotReactionRule", "fullname", "code", "BreakOnFalseReactionRule", "BreakOnTrueReactionRule", "JumpReactionRule", "n", "dynamicDots", "ER", "posts", "ref", "type", "prop", "k", "v", "key", "vars", "res", "p", "triggers", "Er", "ErEvent", "er", "fetch_json", "fetch_text", "AttributeIterator", "root", "Type", "PpIterator", "i", "pathEl", "el", "path", "parentPath", "findNearestPpObject", "PpEvent", "type", "IT", "v", "k", "propagate", "scope", "pp", "Pp", "obj", "a", "loopTask", "template", "key", "triggerName", "clone", "c", "loop", "now", "trigger", "keys", "_", "p", "LoopCube", "old", "exact", "unused", "main", "o", "n", "scale", "oldNodes", "nowNodes", "removeNodes", "u", "LoopCubeAttr", "attr", "j", "start", "loopOptimal", "res", "WindowTrigger", "DocumentTrigger", "DCLTrigger", "PrePropTrigger", "PostPropTrigger", "makeAll", "upCase", "s", "res", "type", "dynamicSimpleProp", "getHoistTemplate", "el", "name", "res", "template_", "rule", "_", "template"]
}
