{
  "version": 3,
  "sources": ["x/dotRule/dot.js", "x/er/v1.js", "x/pp/v1.js", "x/PropagationSimple/prop.js"],
  "sourcesContent": ["const scopes = {\n  \".\": \"this.\",\n  \"e.\": \"window.eventLoop.event.\",\n  \"t.\": \"window.eventLoop.event.target.\",\n  \"w.\": \"window.\",\n  \"d.\": \"window.document.\",\n  // \"i.\": \"args[0].\",  //todo implement this instead of .oi\n  // \"i(0-9)+\": \"args[$1].\",//todo implement this instead of .oi\n  \"oi.\": \"oi.\",\n  \"at.\": \"window.eventLoop.attribute.\", //useful when dash rules have moved the origin\n  \"el.\": \"window.eventLoop.attribute.ownerElement.\", //todo same as this.ownerElement??\n  \"this.\": \"this.\",\n  \"window.\": \"window.\",\n  \"document.\": \"document.\"\n};\n\n//todo must rename oi to i, because of the change of structures.\nfunction processRef(prop) {\n  for (let prefix in scopes)\n    if (prop.startsWith(prefix))\n      return DoubleDots.kebabToPascal(scopes[prefix] + prop.slice(prefix.length));\n}\n\nconst primitives =\n  /^((-?\\d+(\\.\\d+)?([eE][-+]?\\d+)?)|this|window|document|i|e|true|false|undefined|null)$/;\n\nfunction textToExp(txt) {\n  let [prop, ...args] = txt.split(\"_\");\n  const ref = processRef(prop);\n  args = args.map(arg => processRef(arg) || primitives.test(arg) ? arg : `\"${arg}\"`);\n  const sargs = args.join(\", \");\n  const setter = !args.length ? \"\" : args.length === 1 ? `=${sargs}` : `=[${sargs}]`;\n  return `(${ref} instanceof Function ? ${ref}(${sargs}) : (${ref}${setter}))`;\n}\n\nfunction DotReactionRule(fullname) {\n  const exp = textToExp(fullname);\n  const code = `function dotReaction(oi) { return ${exp}; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//basic filters\nfunction BreakOnFalseReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} || EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\nfunction BreakOnTrueReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} && EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//jump\nfunction JumpReactionRule(fullname) {\n  const n = parseInt(fullname.slice(2));\n  if (!n || isNaN(n))\n    throw new DoubleDots.SyntaxError(\"ReactionJump only accept positive and negative integers: \" + fullname.slice(2));\n  // return _ => new EventLoop.ReactionJump(n);\n  return DoubleDots.importBasedEval(`_ => new EventLoop.ReactionJump(${n})`);\n}\n\nconst dynamicDots = {};\nfor (let prefix in scopes)\n  dynamicDots[prefix] = DotReactionRule;\ndynamicDots[\"x.\"] = BreakOnFalseReactionRule;\ndynamicDots[\"y.\"] = BreakOnTrueReactionRule;\ndynamicDots[\"j.\"] = JumpReactionRule;\n\nexport { dynamicDots as dynamicsDots };", "class ER {\n  constructor(posts) {\n    this.posts = posts;\n  }\n\n  * parents(ref, type, prop) {\n    for (let [k, v] of Object.entries(this.posts))\n      if (!type || k.startsWith(type))\n        if (prop && Array.isArray(v[prop]) && v[prop].includes(ref))\n          yield k;\n  }\n\n  parent(ref, type, prop) {\n    return this.parents(ref, type, prop).next().value;\n  }\n\n  //todo this can loop forever, when we have a person with a friend \n  //     that has a friend that is the first person. This won't work.\n  //\n  //todo 1. we need to go width first.\n  //todo 2. we need to check the path. If we are going from:\n  //        person / [friends] / person / [friends]\n  //        then we need to stop at the 2nd [friends].\n  //        we should only resolve person[friends] relationship *once*.\n  //        when we meet person[friends] 2nd time, we should just skip it.\n  //        this means that when we meet \"person\" the second time, \n  //        we should skip all the arrays.\n  resolve(key, vars) {\n    const res = Object.assign({}, vars, this.posts[key]);\n    for (let p in res)\n      if (res[p] instanceof Array)\n        res[p] = res[p].map(k => this.resolve(k, vars));\n    return res;\n  }\n}\n\nlet triggers = new DoubleDots.AttrWeakSet();\n\nexport class Er extends AttrCustom {\n  upgrade() {\n    triggers.add(this);\n  }\n}\n\nclass ErEvent extends Event {\n  constructor(type, er) {\n    super(type);\n    this.er = new ER(er);\n  }\n}\n\nexport function er(posts) {\n  eventLoop.dispatchBatch(new ErEvent(\"er\", posts), triggers);\n}", "class AttributeIterator {\n\n  constructor(root, Type = Attr) {\n    this.elIt = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT);\n    this.Type = Type;\n    this.attr = undefined;\n    this.nextElement();\n  }\n\n  nextElement() {\n    this.el = this.elIt.nextNode();\n    this.i = 0;\n    this.attributes = this.el ? Array.from(this.el.attributes) : [];\n  }\n\n  next() {\n    while (this.el?.isConnected) {\n      while (this.i < this.attributes.length) {\n        this.attr = this.attributes[this.i++];\n        if (this.attr.ownerElement)          //skip removed attributes\n          if (this.attr instanceof this.Type)//if Type===Attr, then no filter\n            return { value: this.attr, done: false };\n      }\n      this.nextElement();\n    }\n    this.attr = undefined;\n    return { done: true };\n  }\n\n  [Symbol.iterator]() { return this; }\n}\n\nclass PpIterator extends AttributeIterator {\n  constructor(root, Type = Attr) {\n    super(root, Type);\n    this.stack = [];\n  }\n  next() {\n    const i = super.next();\n    if (i.done) return i;\n    while (this.stack.length && !this.stack[0].el.contains(this.el))\n      this.stack.shift();\n    const pathEl = this.makePath(i.value, this.stack[0]?.path);\n    this.stack.unshift(pathEl);\n    return i;\n  }\n\n  makePath({ ownerElement: el, value: path }, parentPath = []) {\n    path = path.split(\".\");\n    path = path[0] ? path : [...parentPath, ...path.slice(1)];\n    return { el, path };\n  }\n\n  get currentPath() {\n    return this.stack[0].path;\n  }\n}\n\nfunction findNearestPpObject(el) {\n  for (; el; el = el.parentElement)\n    if (el.pp)\n      return el.pp;\n}\n\nclass PpEvent extends Event {\n  constructor(type, root, IT) {\n    super(type);\n    this.IT = IT;\n    this.root = root;\n  }\n\n  //return IT.currentPath.reduce((o, p) => o?.[p], this.root);\n  get [Event.data]() {\n    let v = this.root;\n    let k;\n    for (k of IT.currentPath)\n      v = v?.[k];\n    return v instanceof Object ?\n      Object.assign({ \"#key\": k }, v) :\n      { \"#key\": k, \"#value\": v };\n  }\n}\n\nfunction propagate(scope, pp) {\n  IT = new PpIterator(scope, Pp);\n  eventLoop.dispatchBatch(new PpEvent(\"pp\", pp, IT), IT);\n}\n\nlet IT;\n\nexport function pp(obj) {\n  if (IT?.attr)\n    throw new Error(\":pp reaction cannot be triggered while the pp: is propagating\");\n  this.ownerElement.pp = obj;\n  obj && propagate(this.ownerElement, obj);\n}\n\nexport class Pp extends AttrCustom {\n  upgrade() {\n    for (let a of this.ownerElement.attributes)\n      if (a !== this && a instanceof Pp)\n        throw new Error(\"An element can only hold one \" + this.trigger + \":\");\n  }\n  set value(v) {\n    super.value = v;\n    if (IT?.attr) {\n      if (IT.attr === this)\n        throw new Error(\"reactions on pp: trigger cannot change their own value!\");\n      if (!IT.attr.ownerElement.contains(this.ownerElement))\n        throw new Error(\"pp: mutation outside scope: \" + IT.attr.ownerElement + \" >! \" + this.ownerElement);\n      return;\n    }\n    const pp = findNearestPpObject(this.ownerElement);\n    pp && propagate(this.ownerElement, pp);\n  }\n  get value() { return super.value; }\n}\n\nfunction loopTask(template, key, triggerName) {\n  const clone = template.cloneNode(true);\n  for (let c of clone.children)\n    for (let a of c.attributes)\n      if (a.name.startsWith(triggerName))\n        return (a.value = \".\" + key), clone;\n  return clone;\n}\n\n//In objects, properties starting with \"#\" such as \n//\"#key\" or \"#private\" will be excluded by the :loop.\nexport function loop(template, now) {\n  if (!(template instanceof DocumentFragment) || !template.children.length)\n    throw new Error(\"loop #1 argument must be a DocumentFragment with at least one child element.\");\n  if (typeof now !== 'object')\n    throw new Error(\"loop #2 argument is not an object.\");\n  const trigger = this.trigger + \":\";\n  this.ownerElement.textContent = \"\";\n  const keys = now instanceof Array ?\n    now.map((_, i) => i) :\n    Object.keys(now).filter(p => !p.startsWith(\"#\"));\n  for (let key of keys)\n    this.ownerElement.append(...loopTask(template, key, trigger).childNodes);\n  return now;\n}\n\n//Optimization attemps. Skipped for now.\n\nclass LoopCube {\n  static compareSmall(old, now) {\n    const exact = new Array(now.length);\n    const unused = [];\n    if (!old?.length)\n      return { exact, unused };\n    main: for (let o = 0; o < old.length; o++) {\n      for (let n = 0; n < now.length; n++) {\n        if (!exact[n] && old[o] === now[n]) {\n          exact[n] = o;\n          continue main;\n        }\n      }\n      unused.push(o);\n    }\n    return { exact, unused };\n  }\n\n  constructor(root, template) {\n    this.root = root;\n    this.template = template;\n    this.tl = template.childNodes.length;\n    this.now = [];\n    this.root.textContent = \"\";\n  }\n\n  getTemplClone() {\n    return this.template.cloneNode(true).childNodes;\n  }\n\n  moveToRes(n, o, now, old, scale) {\n    n *= scale;\n    o *= scale;\n    for (let i = 0; i < scale; i++)\n      now[n + i] = old[o + i];\n  }\n\n  step(now = []) {\n    const old = this.now;\n    this.now = now;\n    const { exact, unused } = LoopCube.compareSmall(old, now);\n\n    const oldNodes = this.root.childNodes;\n    const nowNodes = new Array(now.length * this.tl);\n    for (let n = 0; n < exact.length; n++) {\n      const o = exact[n];\n      if (o != null) {\n        this.moveToRes(n, o, nowNodes, oldNodes, this.tl);\n      } else {\n        unused.length ?\n          this.moveToRes(n, unused.pop(), nowNodes, oldNodes, this.tl) :\n          this.moveToRes(n, 0, nowNodes, this.getTemplClone(), this.tl);\n        this.task(nowNodes, n);\n      }\n    }\n    const removeNodes = [];\n    for (let u = unused.pop(), i = 0; u != null; i++, u = unused.pop())\n      this.moveToRes(i, u, removeNodes, oldNodes, this.tl);\n    return nowNodes;\n  }\n\n  task(i) { }\n}\n\nclass LoopCubeAttr extends LoopCube {\n  constructor(attr, template) {\n    super(attr.ownerElement, template);\n    this.attr = attr;\n    this.triggerName = attr.trigger + \":\";\n  }\n\n  task(nowNodes, i) {\n    for (let j = 0, start = i * this.tl; j < this.tl; j++)\n      if (nowNodes[start + j].attributes)\n        for (let a of nowNodes[start + j].attributes)\n          if (a.name.startsWith(this.triggerName))\n            return a.value = \".\" + i;\n  }\n}\n\nfunction loopOptimal(template, now) {\n  const triggerName = \"pp\";\n  if (!Array.isArray(now))\n    throw new Error(\"loop #2 argument is not an array.\");\n  if (!(template instanceof DocumentFragment) || !template.children.length)\n    throw new Error(\"loop #1 argument must be a DocumentFragment with at least one child element.\");\n  const res = (this.__loop ??= new LoopCubeAttr(this, template)).step(now);\n  res.length ? this.ownerElement.append(...res) : this.ownerElement.innerText = \"\";\n  return now;\n}", "export class WindowTrigger extends AttrListener {\n  get target() { return window; }\n}\n\nexport class DocumentTrigger extends AttrListener {\n  get target() { return document; }\n}\n\nexport class DCLTrigger extends DocumentTrigger {\n  get type() { return \"DOMContentLoaded\"; }\n}\n\nexport class PrePropTrigger extends WindowTrigger { //global _click\n  get type() { return this.trigger.slice(1); } //remove prefix so returns \"click\"\n  get options() { return true; }\n}\n\nexport class PostPropTrigger extends WindowTrigger { //global click_\n  get type() { return this.trigger.slice(-1); } //remove postfix so returns \"click\"\n}\n\nfunction makeAll() {\n  const upCase = s => s[0].toUpperCase() + s.slice(1);\n  const res = {};\n  for (let type of DoubleDots.nativeEvents.element) {\n    type = upCase(type);\n    res[type] = AttrListener;\n    res[\"_\" + type] = PrePropTrigger;\n    res[type + \"_\"] = PostPropTrigger;\n  }\n  for (let type of DoubleDots.nativeEvents.window)\n    res[upCase(type)] = WindowTrigger;\n  for (let type of DoubleDots.nativeEvents.document)\n    res[upCase(type)] = DocumentTrigger;\n  delete res[\"DOMContentLoaded\"];\n  res[\"Domcontentloaded\"] = DCLTrigger;\n  return res;\n}\nexport const dynamicSimpleProp = makeAll();\n\n/**\n# SimplePropagation\n\n>> Note!! You must register the triggers for `custom-event`s too, such as `document.Triggers.define(\"custom-event\", AttrListener);`.\n\nIn HTML events \"propagate\" in the DOM. These events are small data messages that trigger reactions in the form of JS event listener functions.\n\n## Propagation triggers\n\nIn DoubleDots events also propagate in the DOM. DoubleDots use propagation triggers to react to them. For example `click:toggle_open` uses a `click` propagation trigger to react to `click` event and invoke the `:toggle_open` reaction chain.\n\n## `AttrListener`\n\nThe `AttrListener` is a special subtype of `AttrCustom` that handle native event listeners. Most commonly you will only import a set of propagation triggers for native events, and maybe add some of the propagation triggers to your own `custom-event` types. Most DoubleDots environments will deprecate the native event listeners and only allow event listeners to react to propagation triggers that `extends AttrListener`. Both for native events and custom events. \n\n## HowTo: use `custom-event`s in this SimplePropagation setup?\n\nTo `dispatch` and listen for a `custom-event` using SimplePropagation, \nyou must first and only register their triggers:\n\n1. If you only wish to have normal bubble triggers for them, you only register their bubble triggers.\n```js\n  document.Triggers.define(\"custom-event\", AttrListener);  \n```\n\n2. If you wish the event to be a global, you register it as a WindowTrigger.\n```js\n  document.Triggers.define(\"custom-global-event\", WindowTrigger);  \n```\n3. If you wish the event to be global, and you want to use pre- and post-propagation triggers, register all needed triggers.\n```js\n    document.Triggers.define(\"custom-event\", AttrListener);\n    document.Triggers.define(\"_custom-event\", PrePropTrigger);\n    document.Triggers.define(\"custom-event_\", PostPropTrigger);\n```\n\n## DefaultActions, `stopPropagation()` and SimplePropagation\n\nThe SimplePropagation setup enables you to use native default actions normally.\nThis means that you can call `e.preventDefault()` within any reaction chain for that event.\n\nDoubleDots recommend *against* using `e.stopPropagation()` and `e.stopImmediatePropagation()`. But when you use SimplePropagation, you can allow stopPropagation().\n\n## HowTo: `extends AttrListener`\n\nIf you need to implement your own propagation triggers, the `AttrListener` provide the following interface:\n1. `get target()` (default: `this.ownerElement`)\n2. `get type()` (default: `this.trigger`)\n3. `get options()` (default: undefined)\n4. `run(e){...}` (default: `eventLoop.dispatch(e, this)`)\n\n## Performance and consistency\n\nSimplePropagation follows the same logic as native event listeners. This means that:\n1. listeners/triggers can always be removed. This makes sense.\n2. But, *sometimes* listeners can be added and triggered during the same event propagation cycle, *sometimes* not. Listeners added later in the propagation cycle will be triggered, except when they are on the same element in the same phase as the current element.\n3. The sync/async behavior can be confusing, as sometimes each event listener is given its own macro task, sometimes all event listeners are considered *one* macro task, and sometimes the event listeners are considered sync (when dispatched via `dispatchEvent`).\n\nThe overhead per native event listener is not that big. It is quite performant. The only cost is resolving the reaction chain and maintaining the eventLoop state.\n\n## `Event.activeListeners()`\n\nThe AttrListener keeps track of how many listener are active for any event type at any time. Asking `Event.activeListeners(\"click\")` will return the number of active `click` event listeners in the DOM. This method can be used to for example:\n\n1. debug an app to see what it does,\n\n2. to throw error if `dispatchEvent` is called for an event no one is listening for:\n\n```js\nEventTarget.prototype.dispatchEvent(e){\n  if(Event.activeListeners(e.type))\n    throw new DoubleDots.PropagationError(`dispatching event \"${e.type}\" when no one is listening.`);\n  OG.call(this, e);\n}\n```\n*/"],
  "mappings": "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",
  "names": ["scopes", "processRef", "prop", "prefix", "primitives", "textToExp", "txt", "args", "ref", "arg", "sargs", "setter", "DotReactionRule", "fullname", "code", "BreakOnFalseReactionRule", "BreakOnTrueReactionRule", "JumpReactionRule", "n", "dynamicDots", "triggers", "Er", "AttributeIterator", "root", "Type", "_a", "PpIterator", "i", "pathEl", "el", "path", "parentPath", "findNearestPpObject", "PpEvent", "type", "IT", "v", "k", "propagate", "scope", "pp", "Pp", "Pp", "a", "v", "IT", "pp", "findNearestPpObject", "propagate", "WindowTrigger", "DocumentTrigger", "DCLTrigger", "PrePropTrigger", "PostPropTrigger", "makeAll", "upCase", "s", "res", "type", "dynamicSimpleProp"]
}
