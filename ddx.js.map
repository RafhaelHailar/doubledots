{
  "version": 3,
  "sources": ["x/state/v1.js", "x/nav/v1.js", "x/embrace/LoopCube.js", "x/embrace/Tokenizer.js", "x/embrace/v1.js", "x/dotRule/dot.js", "x/er/ErAnalysis.js", "x/at/v1.js", "x/fetch/v2.js", "x/PropagationSimple/prop.js", "x/formdata/v1.js", "x/css/v1.js"],
  "sourcesContent": ["function matchesPath(observedPaths, path) {\n  for (let observedPath of observedPaths)\n    if (path.startsWith(observedPath))\n      return true;\n}\n\nfunction pathsAllSet(observedPaths, state) {\n  for (let path of observedPaths) {\n    let obj = state;\n    for (let p of path) {\n      if (!(p in obj))\n        return false;\n      obj = obj[p];\n    }\n  }\n  return true;\n}\n\nfunction makeIterator(attrs, state, pathString) {\n  if (!pathString)\n    return attrs[Symbol.iterator]();\n  const matches = [];\n  for (let at of attrs) {\n    if(!at.constructor.paths)\n      matches.push(at);\n    else if (matchesPath(at.constructor.branches, pathString))\n      if (pathsAllSet(at.constructor.paths, state))\n        matches.push(at);\n  }\n  return matches[Symbol.iterator]();\n}\n\nconst attrs = {};\nfunction addAttr(at, name) {\n  (attrs[name] ??= new DoubleDots.AttrWeakSet()).add(at);\n}\nconst states = {};\n\nfunction setInObjectCreatePaths(obj, path, key, value) {\n  for (let p of path)\n    obj = (obj[p] ??= {});\n  obj[key] = value;\n}\n\nfunction setInObjectIfDifferent(obj, path, key, value) {\n  const parent = path.reduce((o, p) => o?.[p], obj);\n  if (JSON.stringify(parent?.[key]) === JSON.stringify(value))\n    return false;\n  setInObjectCreatePaths(obj, path, key, value);\n  return true;\n}\n\nexport class State extends AttrCustom {\n  upgrade() { addAttr(this, this.trigger); }\n}\n\nexport function state(value) {\n  const name = eventLoop.reaction;\n  if (JSON.stringify(states[name]) === JSON.stringify(value))\n    return;\n  const e = new Event(\"state\");\n  e[Event.data] = states[name] = value;\n  const it = makeIterator(attrs[name], states[name]);\n  eventLoop.dispatchBatch(e, it);\n}\n\nexport function State_(rule) {\n  const [name, ...branches] = rule.split(\"_\");\n  const paths = branches.map(b => b.split(\".\"));\n  return class State extends AttrCustom {\n    upgrade() { addAttr(this, name); }\n    static get branches() { return branches; }\n    static get paths() { return paths; }\n  };\n}\n\nexport function state_(rule) {\n  let [name, branch] = rule.split(\"_\");\n  const path = branch.split(\".\");\n  const key = path.pop();\n  return function (value) {\n    const change = setInObjectIfDifferent(states[name] ??= {}, path, key, value);\n    if (!change)\n      return;\n    const e = new Event(name);\n    e[Event.data] = states[name];\n    const it = makeIterator(attrs[name], states[name], branch);\n    eventLoop.dispatchBatch(e, it);\n  };\n}", "const triggers = new DoubleDots.AttrWeakSet();\nlet active;\n\nconst LocationEvent = _ => Object.assign(new Event(\"location\"), { [Event.data]: new URL(location) });\n\nexport class Nav extends AttrCustom {\n  upgrade() {\n    if (!active) {\n      for (let e of [\"click\", \"popstate\"])\n        document.documentElement.setAttribute(`${e}:${this.trigger}`);\n      active = true;\n    }\n    triggers.add(this);\n    this.dispatchEvent(LocationEvent());\n  }\n  remove() {\n    triggers.delete(this);\n  }\n}\n\nexport function nav(e) {\n  if (typeof e === \"string\") {\n    const url = new URL(e, location.href);\n    history.pushState(null, null, url.href);\n    return eventLoop.dispatchBatch(LocationEvent(), triggers);\n  }\n  if (!triggers.size) {\n    for (let e of [\"click\", \"popstate\", \"hashchange\"])\n      document.htmlElement.removeAttribute(`${e}:${eventLoop.reaction.name}`);\n    //todo check that this eventLoop.reaction.name is correct\n    active = false;\n    return;\n  }\n  if (e.defaultPrevented)\n    return;\n  if (e.type === \"popstate\") {\n    e.preventDefault();\n  } else if (e.type === \"click\") {\n    const a = e.target.closest(\"a[href]\");\n    if (!a)\n      return;\n    const link = new URL(a.href, location.href);\n    if (link.origin !== window.location.origin)\n      return;\n    history.pushState(null, null, link);\n    e.preventDefault();\n  }\n  eventLoop.dispatchBatch(LocationEvent(), triggers);\n}", "export class LoopCube {\n  static compareSmall(compare, old, now) {\n    const exact = new Array(now.length);\n    const unused = [];\n    if (!old?.length)\n      return { exact, unused };\n    main: for (let o = 0; o < old.length; o++) {\n      for (let n = 0; n < now.length; n++) {\n        if (!exact[n] && compare(old[o], now[n])) {\n          exact[n] = o;\n          continue main;\n        }\n      }\n      unused.push(o);\n    }\n    return { exact, unused };\n  }\n\n  constructor(embrace, compare = (a, b) => a === b) {\n    this.embrace = embrace;\n    this.now = [];\n    this.nowEmbraces = [];\n    this.comparator = LoopCube.compareSmall.bind(null, compare);\n  }\n\n  step(now = []) {\n    const old = this.now;\n    const oldEmbraces = this.nowEmbraces;\n    this.now = now;\n    const { exact, unused } = this.comparator(old, now);\n    const embraces = new Array(now.length);\n    const changed = [];\n    for (let n = 0; n < exact.length; n++) {\n      const o = exact[n];\n      if (o != null) {\n        embraces[n] = oldEmbraces[o];\n      } else {\n        changed.push(n);\n        embraces[n] = unused.length ? oldEmbraces[unused.shift()] : this.embrace.clone();\n      }\n    }\n    this.nowEmbraces = embraces;\n    const removes = unused.map(o => oldEmbraces[o]);\n    return { embraces, removes, changed };\n  }\n}", "const loophole = /\\b(?:JSON.stringify|Object.values|Object.keys|Object.entries|(?:instanceof\\s+(?:[\\p{L}\\p{N}_$]+)))\\b/;\nconst ignore = /\\b(?:break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|interface|let|new|null|package|private|protected|public|return|static|switch|throw|true|try|typeof|var|void|while|with|yield|async|await|\\s+)\\b/; //space are ignored\nconst dotWords = /\\.\\s*[\\p{L}_$][\\p{L}\\p{N}_$]*(?:\\s*\\.\\s*[\\p{L}\\p{N}_$]+)*/u;\nconst words = /#?[\\p{L}_$][\\p{L}\\p{N}_$]*(?:\\s*\\.\\s*[\\p{L}\\p{N}_$]+)*/u;\nconst quote1 = /'([^'\\\\]*(\\\\.[^'\\\\]*)*)'/;\nconst quote2 = /\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/;\nconst number = /0[xX][0-9a-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?/;\nconst regex = /\\/[^/\\\\]*(?:\\\\.[^/\\\\]*)*\\/[gimyu]*/;\nconst linecomment = /\\/\\/[^\\n]*/;\nconst starcomment = /\\/\\*[^]*?\\*\\//;\n\n//todo so many security problems. Mainly with [\"lookup\"] and (\"something\"||[]).dot.lookups\n\n//0. [].constructor. \n//02. [][\"constructor\"] => That will give us the Array object without any dotWords. Only [] lookups.\n//1. template strings: `comments ${here can come devils}`. strategy 1) make it throw an error, 2) tokenize ${} inside recursively?..\n//2. something[\"bad\"].CAN.HAPPEN.HERE.constructor.__proto__.etc strategy a) make it throw an error? b) make the function work hiddenly?\n// const dangerous = /super|window|this|document|globalThis|arguments|Function|eval/;\n// These dangerous words are captured, replaced with args[1], and attempted gotten from the context. Thus, they are safe.\n\nconst tokens = [loophole, ignore, words, dotWords, quote1, quote2, number, linecomment, starcomment, regex];\nconst tokenizer = new RegExp(tokens.map(r => `(${r.source})`).join(\"|\"), \"gu\");\n\nexport function extractArgs(txt) {\n  return txt.replaceAll(tokenizer, (o, l, i, p) =>\n    p ? `args(\"${p.replace(/\\s+/g, \"\")}\")` : o);\n}\n\nexport function interpretTemplateString(txt) {\n  return `\\`${txt.split(/{{([^}]+)}}/).map((str, i) =>\n    i % 2 ?\n      `\\${(v = ${extractArgs(str)}) === false || v === undefined ? \"\": v}` :\n      str.replaceAll(\"`\", \"\\\\`\")).join(\"\")}\\``;\n}\n\nconst tsts = [[\n  `series instanceof Array`,\n  `args(\"series\") instanceof Array`\n], [\n  `//the word are all references. They will *all* be replaced with arg[i]\n  const word = / #something.else */u;\n  const quote = / name /;\n  const number = /n . a . m . e/;\n  const regex = /\\/[^/\\\\]*(?:\\\\.[^/\\\\]*)*\\/[gimyu]*/;\n  const starcomment = /\\/\\*[^]*?\\*\\//;`,\n\n  `//the word are all references. They will *all* be replaced with arg[i]\n  const args(\"word\") = / #something.else */u;\n  const args(\"quote\") = / name /;\n  const args(\"number\") = /n . a . m . e/;\n  const args(\"regex\") = //[^/\\\\]*(?:\\\\.[^/\\\\]*)*/[gimyu]*/;\n  const args(\"starcomment\") = //*[^]*?*//;`\n], [\n  `name hello . sunshine #hello.world bob123 _123`,\n  `args(\"name\") args(\"hello.sunshine\") args(\"#hello.world\") args(\"bob123\") args(\"_123\")`\n], [\n  `name.hello[\"bob\"].sunshine  . bob`,\n  `args(\"name.hello\")[\"bob\"].sunshine  . bob`\n],\n  //todo this last test.. it should actually turn this into args(\"name.hello.bob.sunshine.bob\"), right? We should disallow property names with space in them? \" \"\n\n];\n\nfunction test() {\n  for (let [before, after] of tsts) {\n    const exp = extractArgs(before).trim();\n    if (exp !== after)\n      console.log(exp);\n  }\n}\n\n// test();", "import { LoopCube } from \"./LoopCube.js\";\nimport { extractArgs, interpretTemplateString } from \"./Tokenizer.js\";\n\n//Template engine\nfunction dotScope(data, superior, cache = {}) {\n  const me = function scope(path) {\n    return path.constructor === Object ? dotScope(data, me, path) :\n      path === \"$\" ? data : cache[path] ??=\n        path.split('.').reduce((o, p) => o?.[p], cache) ??\n        superior?.(path) ??\n        path.split('.').reduce((o, p) => o?.[p], data);\n  };\n  return me;\n}\n\nclass EmbraceRoot {\n  constructor(name, docFrag, nodes, expressions) {\n    this.name = name;\n    this.template = docFrag;\n    this.nodes = nodes;\n    this.topNodes = [...docFrag.childNodes];\n    this.expressions = expressions;\n    this.todos = [];\n    for (let i = 0; i < expressions.length; i++)\n      if (expressions[i])\n        this.todos.push({ exp: expressions[i], node: nodes[i] });\n  }\n\n  clone() {\n    const docFrag = this.template.cloneNode(true);\n    const nodes = [...flatDomNodesAll(docFrag)];\n    return new EmbraceRoot(this.name, docFrag, nodes, this.expressions);\n  }\n\n  run(scope, _, ancestor) {\n    for (let { exp, node } of this.todos)\n      if (ancestor.contains(node.ownerElement ?? node))\n        exp.run(scope, node, ancestor);\n  }\n\n  prep(funcs) {\n    for (let { exp } of this.todos) {\n      exp.cb = funcs[exp.name];\n      exp.innerRoot?.prep(funcs);\n    }\n  }\n\n  runFirst(el, dataObject, funcs) {\n    this.prep(funcs);\n    el.prepend(...this.topNodes);\n    this.run(dotScope(dataObject), 0, el);\n  }\n}\n\nclass EmbraceTextNode {\n  constructor(name, exp) {\n    this.name = name;\n    this.exp = exp;\n  }\n\n  run(scope, node) {\n    node.textContent = this.cb(scope);\n  }\n}\n\nclass EmbraceCommentFor {\n  constructor(name, innerRoot, varName, exp) {\n    this.name = name;\n    this.innerRoot = innerRoot;\n    this.varName = varName;\n    this.exp = exp;\n    this.cb;\n    this.iName = `#${varName}`;\n    this.dName = `$${varName}`;\n  }\n\n  run(scope, node, ancestor) {\n    let list = this.cb(scope) ?? [];\n    const inMode = !(Symbol.iterator in list);\n    const cube = node.__cube ??=\n      new LoopCube(this.innerRoot, inMode ? (a, b) => JSON.stringify(a) === JSON.stringify(b) : undefined);\n    const now = inMode ? Object.entries(list) : list;\n    const { embraces, removes, changed } = cube.step(now);\n    for (let em of removes)\n      for (let n of em.topNodes)\n        n.remove();\n    for (let em of embraces) \n      node.before(...em.topNodes);\n    for (let i of changed) {\n      const subScope = { [this.iName]: i };\n      if (inMode) {\n        subScope[this.varName] = now[i][1];\n        subScope[this.dName] = now[i][0];\n      } else {\n        subScope[this.varName] = now[i];\n      }\n      embraces[i].run(scope(subScope), undefined, ancestor);\n    }\n  }\n}\n\nclass EmbraceCommentIf {\n  constructor(name, emRoot, exp) {\n    this.name = name;\n    this.innerRoot = emRoot;\n    this.exp = exp;\n  }\n\n  run(argsDict, node, ancestor) {\n    const em = node.__ifEmbrace ??= this.innerRoot.clone();\n    const test = !!this.cb(argsDict);\n    //we are adding state to the em object. instead of the node.\n    if (test && !em.state)\n      node.before(...em.topNodes);\n    else if (!test && em.state)\n      node.append(...em.topNodes);\n    if (test)\n      em.run(argsDict({}), undefined, ancestor);\n    em.state = test;\n  }\n}\n\n//PARSER\nfunction* flatDomNodesAll(docFrag) {\n  const it = document.createNodeIterator(docFrag, NodeFilter.SHOW_ALL);\n  for (let n = it.nextNode(); n = it.nextNode();) {\n    yield n;\n    if (n instanceof Element) yield* n.attributes;\n  }\n}\n\nfunction parseTemplate(template, name = \"embrace\") {\n  const nodes = [...flatDomNodesAll(template.content)];\n  const expressions = nodes.map((n, i) => parseNode(n, name + \"_\" + i));\n  return new EmbraceRoot(name, template.content, nodes, expressions);\n}\n\nfunction parseNode(n, name) {\n  if (n instanceof Text || n instanceof Attr || n instanceof Comment) {\n    if (n.textContent.match(/{{([^}]+)}}/))\n      return new EmbraceTextNode(name, n.textContent);\n  } else if (n instanceof HTMLTemplateElement) {\n    const emTempl = parseTemplate(n, name);\n    let res;\n    if (res = n.getAttribute(\"for\")) {\n      const ctrlFor = res.match(/^\\s*([^\\s]+)\\s+(?:of)\\s+(.+)\\s*$/);\n      if (!ctrlFor)\n        throw new SyntaxError(\"embrace for error: \" + res);\n      const [, varName, exp] = ctrlFor;\n      return new EmbraceCommentFor(name, emTempl, varName, exp);\n    }\n    if (res = n.getAttribute(\"if\"))\n      return new EmbraceCommentIf(name, emTempl, res);\n    return emTempl;\n  }\n}\n\nfunction extractFuncs(root, res = {}) {\n  for (let { exp } of root.todos) {\n    const code =\n      exp instanceof EmbraceTextNode ? interpretTemplateString(exp.exp) :\n        exp instanceof EmbraceCommentFor ? extractArgs(exp.exp) :\n          exp instanceof EmbraceCommentIf ? extractArgs(exp.exp) :\n            undefined;\n    res[exp.name] = `(args, v) => ${code}`;\n    if (exp.innerRoot)\n      extractFuncs(exp.innerRoot, res);\n  }\n  return res;\n}\n\n//TUTORIAL\n\nfunction hashDebug(script, id) {\n  return `Add the following script in the <head> element:\n\n<script embrace=\"${id}\">\n  (window.Embrace ??= {})[\"${id}\"] = ${script};\n</script>`;\n}\n\n// :embrace\nexport function embrace(dataObject) {\n  let em = this.ownerElement.__embrace;\n  if (em)\n    return em.run(dotScope(dataObject), 0, this.ownerElement);\n  const id = this.ownerElement.id || \"embrace\";\n  const templ = this.ownerElement.firstElementChild;\n  if (!(templ instanceof HTMLTemplateElement))\n    throw new Error(\"This first element child of :embrace ownerElement must be a template\");\n  em = this.ownerElement.__embrace = parseTemplate(templ, id);\n  if (window.Embrace?.[id])\n    return em.runFirst(this.ownerElement, dataObject, window.Embrace[id]);\n  const funcs = extractFuncs(em);\n  const script = \"{\\n\" + Object.entries(funcs).map(([k, v]) => `${k}: ${v}`).join(',\\n') + \"\\n}\";\n  DoubleDots.importBasedEval(script).then(funcs => {\n    DoubleDots.log?.(\":embrace production\", hashDebug(script, id));\n    (window.Embrace ??= {})[id] = funcs;\n    em.runFirst(this.ownerElement, dataObject, funcs);\n  });\n}", "const scopes = {\n  \".\": \"this.\",\n  \"e.\": \"window.eventLoop.event.\",\n  \"t.\": \"window.eventLoop.event.target.\",\n  \"w.\": \"window.\",\n  \"d.\": \"window.document.\",\n  // \"i.\": \"args[0].\",  //todo implement this instead of .oi\n  // \"i(0-9)+\": \"args[$1].\",//todo implement this instead of .oi\n  \"oi.\": \"oi.\",\n  \"at.\": \"window.eventLoop.attribute.\", //useful when dash rules have moved the origin\n  \"el.\": \"window.eventLoop.attribute.ownerElement.\", //todo same as this.ownerElement??\n  \"this.\": \"this.\",\n  \"window.\": \"window.\",\n  \"document.\": \"document.\"\n};\n\n//todo must rename oi to i, because of the change of structures.\nfunction processRef(prop) {\n  for (let prefix in scopes)\n    if (prop.startsWith(prefix))\n      return DoubleDots.kebabToPascal(scopes[prefix] + prop.slice(prefix.length));\n}\n\nconst primitives =\n  /^((-?\\d+(\\.\\d+)?([eE][-+]?\\d+)?)|this|window|document|i|e|true|false|undefined|null)$/;\n\nfunction textToExp(txt) {\n  let [prop, ...args] = txt.split(\"_\");\n  const ref = processRef(prop);\n  args = args.map(arg => processRef(arg) || primitives.test(arg) ? arg : `\"${arg}\"`);\n  const sargs = args.join(\", \");\n  const setter = !args.length ? \"\" : args.length === 1 ? `=${sargs}` : `=[${sargs}]`;\n  return `(${ref} instanceof Function ? ${ref}(${sargs}) : (${ref}${setter}))`;\n}\n\nfunction DotReactionRule(fullname) {\n  const exp = textToExp(fullname);\n  const code = `function dotReaction(oi) { return ${exp}; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\n//basic filters\nfunction BreakOnFalseReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} || EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\nfunction BreakOnTrueReactionRule(fullname) {\n  const exp = textToExp(fullname.slice(2));\n  const code = `function dotReaction(oi) { return ${exp} && EventLoop.break; }`;\n  return DoubleDots.importBasedEval(code);\n}\n\nconst dynamicDots = {};\nfor (let prefix in scopes)\n  dynamicDots[prefix] = DotReactionRule;\ndynamicDots[\"x.\"] = BreakOnFalseReactionRule;\ndynamicDots[\"y.\"] = BreakOnTrueReactionRule;\n\nexport { dynamicDots as dynamicsDots };", "export class ER {\n  constructor(posts) {\n    this.posts = posts;\n  }\n\n  * parents(ref, type, prop) {\n    for (let [k, v] of Object.entries(this.posts))\n      if (!type || k.startsWith(type))\n        if (prop && Array.isArray(v[prop]) && v[prop].includes(ref))\n          yield k;\n  }\n\n  parent(ref, type, prop) {\n    return this.parents(ref, type, prop).next().value;\n  }\n\n  //todo this can loop forever, when we have a person with a friend \n  //     that has a friend that is the first person. This won't work.\n  //\n  //todo 1. we need to go width first.\n  //todo 2. we need to check the path. If we are going from:\n  //        person / [friends] / person / [friends]\n  //        then we need to stop at the 2nd [friends].\n  //        we should only resolve person[friends] relationship *once*.\n  //        when we meet person[friends] 2nd time, we should just skip it.\n  //        this means that when we meet \"person\" the second time, \n  //        we should skip all the arrays.\n  resolve(key, vars) {\n    const res = Object.assign({}, vars, this.posts[key]);\n    for (let p in res)\n      if (res[p] instanceof Array)\n        res[p] = res[p].map(k => this.resolve(k, vars));\n    return res;\n  }\n}\n\nexport class ErAnalysis extends ER {\n\n  //step 1\n  static entitiesToTypeValue(posts) {\n    const res = {};\n    for (let id in posts) {\n      const post = posts[id];\n      const type = post.type;\n      const entityType = res[type] ??= {};\n      for (let prop in post) {\n        const values = entityType[prop] ??= [];\n        values.push(post[prop]);\n      }\n    }\n    return res;\n  }\n\n  //step 2\n  static extractTypeList(list) {\n    const types = [...new Set(list.map(ErAnalysis.extractType))].sort();\n    if (types.includes(\"text\") && types.includes(\"textmd\"))\n      types.splice(types.indexOf(\"text\"), 1);\n    if (types.includes(\"int\") && types.includes(\"float\"))\n      types.splice(types.indexOf(\"int\"), 1);\n    if (types[0].startsWith(\"list: \")) {\n      let refs = types.map(t => t.slice(6).split(\",\"));\n      return [...new Set(refs.flat().filter(Boolean))];\n    }\n    if (types.length === 1)\n      return types[0];\n    debugger;\n    throw new Error(\"should be fixed..\");\n  }\n\n  static isMarkDown(value) {\n    if (!(/[#*_~`]/.test(value)))\n      return;\n    const markdownPatterns = [\n      /\\*\\*.*?\\*\\*/,         // bold (**text**)\n      /\\*.*?\\*/,             // italics (*text*)\n      /~~.*?~~/,             // strikethrough (~~text~~)\n      /`.*?`/,               // inline code (`code`)\n      /#+\\s+.+/,             // headings (# heading, ## subheading, etc.)\n      /\\[.*?\\]\\(.*?\\)/,      // links ([text](url))\n      /!\\[.*?\\]\\(.*?\\)/,     // images (![alt](url))\n      /^>\\s+.+/m             // blockquotes (> quote)\n    ];\n    for (const pattern of markdownPatterns)\n      if (pattern.test(value))\n        return \"textmd\";\n  }\n\n  static extractType(value) {\n    if (Array.isArray(value))\n      return \"list: \" + [...new Set(value.map(str => str.split(\"/\")[0]))].join(\",\");\n    // if (typeof value === 'string' && !isNaN(Date.parse(value)))\n    //   return \"date\";\n    try {\n      // only absolute urls\n      // not relative urls. so \"./hello.png\" is not a url... todo\n      if (decodeURI(new URL(value).href) === decodeURI(value)) return \"url\";\n    } catch (_) { }\n    if ((/^#([0-9A-F]{3}){1,2}$/i).test(value))\n      return \"color\";\n    if (Number(value) + \"\" === value)\n      return \"number\";\n    return ErAnalysis.isMarkDown(value) ?? \"text\";\n  }\n\n  static valuesToTypes(typeValueSchema) {\n    const res = {};\n    for (let type in typeValueSchema) {\n      const entityType = res[type] = {};\n      const propValues = typeValueSchema[type];\n      for (let prop in propValues)\n        entityType[prop] = ErAnalysis.extractTypeList(propValues[prop]);\n    }\n    return res;\n  }\n\n  //step 3 relations\n  static topologicalSort(schemas, cp) {\n    const sortedSchemas = [];\n    const visited = new Set();\n    const tempMarked = new Set();\n\n    function visit(schema) {\n      if (tempMarked.has(schema))\n        throw new Error(\"Cycle detected, schema relationships form a loop.\");\n      if (!visited.has(schema)) {\n        tempMarked.add(schema);\n        const referencedSchemas = cp[schema] || new Set();\n        for (const referred of referencedSchemas)\n          visit(referred);\n        tempMarked.delete(schema);\n        visited.add(schema);\n        sortedSchemas.push(schema);\n      }\n    }\n    for (const schema in schemas)\n      visit(schema);\n    return sortedSchemas;\n  }\n\n  static bottomUpRelations(schemaType) {\n    const res = {};\n    for (let type in schemaType)\n      for (let prop in schemaType[type])\n        if (schemaType[type][prop] instanceof Array)\n          for (let referred of schemaType[type][prop])\n            (res[referred] ??= new Set()).add(type);\n    return res;\n  }\n\n  static analyze(posts) {\n    const schemaTypeValues = ErAnalysis.entitiesToTypeValue(posts);\n    const schemaTypedUnsorted = ErAnalysis.valuesToTypes(schemaTypeValues);\n    const relationsUp = ErAnalysis.bottomUpRelations(schemaTypedUnsorted);\n    const entitySequence = ErAnalysis.topologicalSort(schemaTypedUnsorted, relationsUp);\n    return entitySequence.map(type => [type, schemaTypedUnsorted[type]]);\n  }\n\n  #schema;\n  #schemaSorted;\n  get schema() {\n    return this.#schema ??= Object.fromEntries(this.schemaSorted);\n  }\n  get schemaSorted() {\n    return this.#schemaSorted ??= ErAnalysis.analyze(this.posts);\n  }\n}", "export function gatRule(name) {\n  name = name.split(\".\")[1];\n  return function gat() { return this.ownerElement.getAttribute(name); };\n}\nexport function sat_Rule(name) {\n  name = name.split(\".\")[1];\n  if (!name)\n    return function sat_(input) { return this.value = parseStringValue(input); }\n  return function sat_(input) { return this.ownerElement.setAttribute(name, parseStringValue(input)); };\n}\nexport function tat_Rule(name) {\n  name = name.split(\".\")[1];\n  if (!name)\n    throw new SyntaxError(\"In :DD you can't do tat_ on the current attribute.\");\n  return function tat_(input) { return this.ownerElement.toggleAttribute(name); };\n}\nexport function rat_Rule(name) {\n  name = name.split(\".\")[1];\n  return function rat_(input) { return this.ownerElement.removeAttribute(name); };\n}", "const RESPONSE_TYPES = {\n  json: \"json\",\n  text: \"text\",\n  blob: \"blob\",\n  form: \"formData\",\n  formdata: \"formData\",\n  bytes: \"bytes\",\n  uint8array: \"bytes\",\n  uint8: \"bytes\",\n  clone: \"clone\",\n  arraybuffer: \"arrayBuffer\",\n  buffer: \"arrayBuffer\",\n};\nfunction parseResponseType(tail) {\n  if (!tail) return \"json\";\n  if (RESPONSE_TYPES[tail]) return RESPONSE_TYPES[tail];\n  throw new SyntaxError(\"Unknown fetch- response type: \" + tail);\n}\n\nconst METHOD = {\n  post: 'POST',\n  put: 'PUT',\n  delete: 'DELETE',\n  patch: 'PATCH',\n};\nconst dotMETHOD = {\n  get: 'GET',\n  head: 'HEAD',\n};\nconst HEADERS = {\n  auth: [\"credentials\", 'include'],\n  omit: [\"credentials\", 'omit'],\n\n  nocache: [\"cache\", 'no-cache'],\n  nostore: [\"cache\", 'no-store'],\n  reload: [\"cache\", 'reload'],\n  forcecache: [\"cache\", 'force-cache'],\n  onlyifcached: [\"cache\", 'only-if-cached'],\n\n  cors: [\"mode\", 'cors'],\n  nocors: [\"mode\", 'no-cors'],\n  sameorigin: [\"mode\", 'same-origin'],\n\n  noreferrer: [\"referrerPolicy\", 'no-referrer'],\n  origin: [\"referrerPolicy\", 'origin'],\n  originwhencross: [\"referrerPolicy\", 'origin-when-cross-origin'],\n  strictorigin: [\"referrerPolicy\", 'strict-origin'],\n  strictorigincross: [\"referrerPolicy\", 'strict-origin-when-cross-origin'],\n  unsafe: [\"referrerPolicy\", 'unsafe-url'],\n  refsameorigin: [\"referrerPolicy\", 'same-origin'],\n};\nfunction parseSegments(name, splitter, methodMap) {\n  const [, ...segments] = name.toLowerCase().split(splitter);\n  let method;\n  let responseType;\n  const headers = {};\n  for (let seg of segments) {\n    if (methodMap[seg]) {\n      if (method)\n        throw new SyntaxError(\"multiple fetch methods: \" + methodMap[seg] + \", \" + seg);\n      method = methodMap[seg];\n    } else if (HEADERS[seg]) {\n      const [type, value] = HEADERS[seg];\n      if (type in headers)\n        throw new SyntaxError(\"multiple fetch headers of same type: \" + type + \", \" + seg);\n      headers[type] = value;\n    } else {\n      throw new SyntaxError(\"unknown fetch segment: \" + seg);\n    }\n  }\n  return { method, responseType, headers };\n}\n\n//Att! fetch defaults to .json(), not .text()!\nexport async function basicFetch() { return (await fetch(this.value)).json(); }\n\nexport function fetchDashRule(name) {\n  const [head, type, tail] = name.split(/([._])/);\n  const responseType = parseResponseType(tail);\n  const m = type === \".\" ? \"GET\" : \"POST\";\n  const { headers, method = m } = parseSegments(head, \"-\", type === \".\" ? dotMETHOD : METHOD);\n  return type === \".\" ?\n    async function fetchDash() {\n      return (await fetch(this.value, { method, headers }))[responseType]();\n    } :\n    async function fetchDash_(body) {\n      //todo should we check the body?? nah, dont think so..\n      return (await fetch(this.value, { method, headers, body }))[responseType]();\n    };\n}\n\n//fetch.\nexport function fetchDotRule(name) {\n  const [, tail] = name.split(\".\");\n  const responseType = parseResponseType(tail);\n  return async function fetchDash() {\n    return (await fetch(this.value, { method: \"GET\" }))[responseType]();\n  }\n}\n\n//fetch_\nexport function fetch_Rule(name) {\n  const [, tail] = name.split(\"_\");\n  const responseType = parseResponseType(tail);\n  return async function fetch_(body) {\n    //todo should we check the body?? nah, dont think so..\n    return (await fetch(this.value, { method: \"POST\", body }))[responseType]();\n  };\n}", "export class WindowTrigger extends AttrListener {\n  get target() { return window; }\n}\n\nexport class DocumentTrigger extends AttrListener {\n  get target() { return document; }\n}\n\nexport class DCLTrigger extends DocumentTrigger {\n  get type() { return \"DOMContentLoaded\"; }\n}\n\nexport class PrePropTrigger extends WindowTrigger { //global _click\n  get type() { return this.trigger.slice(1); } //remove prefix so returns \"click\"\n  get options() { return true; }\n}\n\nexport class PostPropTrigger extends WindowTrigger { //global click_\n  get type() { return this.trigger.slice(-1); } //remove postfix so returns \"click\"\n}\n\nfunction makeAll() {\n  const upCase = s => s[0].toUpperCase() + s.slice(1);\n  const res = {};\n  for (let type of DoubleDots.nativeEvents.element) {\n    type = upCase(type);\n    res[type] = AttrListener;\n    res[\"_\" + type] = PrePropTrigger;\n    res[type + \"_\"] = PostPropTrigger;\n  }\n  for (let type of DoubleDots.nativeEvents.window)\n    res[upCase(type)] = WindowTrigger;\n  for (let type of DoubleDots.nativeEvents.document)\n    res[upCase(type)] = DocumentTrigger;\n  delete res[\"DOMContentLoaded\"];\n  res[\"Domcontentloaded\"] = DCLTrigger;\n  return res;\n}\nexport const dynamicSimpleProp = makeAll();", "export function formdata_(rule) {\n  const [, type] = rule.split(\"_\");\n  if (type === \"json\")\n    return function formdata_json(form) {\n      const obj = Object.create(null);\n      for (const [key, value] of new FormData(form))\n        !(key in obj) ? obj[key] = value :\n          Array.isArray(obj[key]) ? obj[key].push(value) :\n            obj[key] = [obj[key], value];\n      return obj;\n    };\n  if (type === \"urlencoded\")\n    return form => new URLSearchParams(new FormData(form));\n  if(type === \"multipart\")\n    return form => new FormData(form);\n  if(type === \"blob\")\n    return form => new Blob([new URLSearchParams(new FormData(form))], { type: \"application/x-www-form-urlencoded\" });\n  throw new SyntaxError(`Invalid formdata type: ${type}. Must be \"json\" or \"urlencoded\".`);\n}", "// import { SheetWrapper } from \"http://127.0.0.1:3003/src/engine.js\";\nimport { SheetWrapper } from \"https://cdn.jsdelivr.net/gh/orstavik/csss@1.0.5/src/engine.js\";\n\nlet sheetWrapper;\nexport class Csss extends AttrCustom {\n\n  upgrade() {\n    if (this.ownerElement.tagName === \"STYLE\")\n      sheetWrapper = new SheetWrapper(this.ownerElement.sheet);\n    else\n      console.warn(\"The 'csss' attribute should be used on a <style> element.\");\n  }\n  set value(v) { sheetWrapper.readSupers(super.value = v); }\n  get value() { return super.value; }\n}\n\nfunction overlap({ rule: { shorts: A } }, { rule: { shorts: B } }) {\n  for (const a in A)\n    for (const b in B)\n      if (a === b) return a;\n}\n\nexport class Class extends AttrCustom {\n\n  upgrade() {\n    this.__previousClasses = {};\n  }\n\n  set value(v) {\n    super.value = v;\n    let positions = [], last = -1;\n    for (let clz of this.ownerElement.classList) {\n      if (clz.includes(\"$\")) {\n        const ruleAndPos = sheetWrapper.addRule(clz);\n        const { pos, rule } = ruleAndPos;\n        positions[pos] = ruleAndPos;\n        if (pos < last) {\n          const potentialErrors = positions.filter((_, i) => i > pos);\n          for (let potential of potentialErrors) {\n            const doubleKey = overlap(ruleAndPos, potential);\n            if (doubleKey)\n              console.warn(`Wrong sequence!! ${clz} should be positioned before ${potential}.`);\n          }\n        } else\n          last = pos;\n      }\n    }\n  }\n\n  get value() { return super.value; }\n}\n"],
  "mappings": "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",
  "names": ["state", "attrs", "e", "embrace", "test", "funcs"]
}
