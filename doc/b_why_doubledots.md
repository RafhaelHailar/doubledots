# Why DoubleDots?

>> Everything written here is true. But still. Be forewarned. This is a sales pitch. This is the way we would present the benefits of DoubleDots when we throw causion and humility to the side. We hope you find it inspiring, and enlightening, and that you forgive us for this bluster and temporary lapse in character.

Below are 6 points why DoubleDots is memorable. Once you see HTML throught the lens of DoubleDots, you will never be able to unsee it. It is unforgettable.

1. DoubleDots renovates the **timeline** in HTML. It unifies all the different timers, callbacks, observers, and the native event queue into a single **virtual event loop**. This makes it much easier to understand the different priorities between tasks (promises, micro, meso, macro, etc.). This illustrates not only how to solve and avoid race conditions between these different queues that now are quite obfuscated, but it also illustrate the clear difference between the thread structure `async/await` allows and how these threads should be viewed up against the singularity of the event loop.

2. Adding only ***`:`*** to HTML attribute names DoubleDots enable you to **program rich web apps in HTML only**. Let that sink in.. One grammatical extension to HTML, that fits seamlessly with HTML, and you no longer need to use JS if you don't want to. ***One***! Because of this syntactic elegance, the DoubleDots run-time environment with a complete virtual event loop can be added as a simple drop-in script. Of less than 1000 readable lines of code. But, the main strength of DoubleDots is not its super efficient run-time; the power of DoubleDots grammar is its ability to help you **see the simplicity of how to program directly against the event loop**. The **clear, simple syntax** of DoubleDots give you a **clear, simple tool for thought** for seeing problems and solutions in terms of event loop. Once you understand how you can program directly against the event loop in DoubleDots, you will know how to program directly against any event loop. That insight is the true value.
 
3. React was right! Functions should be understood as "react"ions. Reaction based programming is a *really good* programming philosophy, on par with pure functions, pure data, the event loop, async/await, etc. However, DoubleDots takes the concept of "reaction" to new heights. You ain't seen nothing yet. I promise. In DoubleDots, you can be excused for thinking that *all* functions are reactions. Or reaction chains. Because DoubleDots is based in a landscape and run-time that you already know very well (HTML, js, and a browser), it is **easy** to understand. Because DoubleDots adds only the `:` doubledot and some reactions, it is **simple** to learn. And based *only* on these principles, DoubleDots still shows you the true meaning of reactive programming. DoubleDots ***will forever shape*** the way you see and understand a world of reactions is.

4. DoubleDots provide a **great** debugging experience. DevTools have solved the issue of showing you **data**: what is going on *where and why*. But, *when* things are *going to happen*, the ***why when***, that is still a mystery in DevTools. This mystery is really a headscratcher. And it is due to the many different queues, the many unregistered tasks, and the `async` threads that in modern js apps now run rampant. The virtual event loop in *DoubleDots solves this problem*. DoubleDots will ***show you time***. By registering *everything relevant that happens* in the browser in one linear event loop, and by registering which reaction starts and completes when, DoubleDots can at any point ***list and color code*** completed, awaiting, and queued events, tasks, and reaction chains.

5. DoubleDots makes **server-side rendering** and making **pausable apps** a breeze! DoubleDots is a reactive, serializable, and deterministic language. What does this mean? Well, DoubleDots push you to make pure reactions. Pure reactions are functions that given the same input DOM always produce the same output DOM. This means that if you are active keeping state in the DOM (such as in css classes and attributes, instead of as js properties and variables), you can save and resurrect the state of the DOM by simply saving `.outerHTML` and `.innerHTML`.

6. DoubleDots is built for **snapshot testing**. By simply reading and writing for example `document.documentElement.outerHTML` at different points of the eventLoop, we can accurately and fully compare the state of all reactive functins. As long as the state of the app is explicit in the DOM, then making a snapshot is *always* as easy as calling `.innerHTML` or `.outerHTML` on some DOM branch.

7. *The DOM is mutable*. The DOM is a *write-in-place construct*. This means that to enable **time-travel** and make sequences of events **replayable**, then you need to be able to re-render parts of the mutable DOM. JS based frameworks commonly do this by combining a single-state json object with template functions that update the DOM to fit the state, while reusing as many existing element objects as possible. You can of course do the same json+reuse-template-functions in DoubleDots, but DoubleDots also offer a *second time-machine-mechanism*: You select the branch in the DOM that you want to time-travel within, eg. `<body>` or `<main>`. You then take full `string` snapshots of `.innerHTML` of this branch, and then store them in a history array. To jump in time, you simply select a point and then invoke a function/reaction that replaces the `.innerHTML` of your branch with the history `string`. If you want to reuse existing DOM element, you can.

Pushing developers towards keeping state explicit in the DOM always, DoubleDots highlight the *problems* you can occure when *time-traveling*: many things such as sockets cannot/shouldn't be serialized; side-effects such as writing to a server database persist when you time-travel in the client; and real world state such as unix time and mousepointer positions are just as sticky as external server state. Hence, time-travel is *only* possible for branches in the apps and sequences of events that **don't** a) use non-serializable resources, b) have side-effects to external or local data sources, and c) use real world state such as in gestures and time-based interaction. Neither in DoubleDots nor on other platforms. 

8. Using reactions and triggers, DoubleDots also give new meaning to the concept of state machines. State machines is a recurring problem in HTML (and coding in general). But, imperative languages like JS are not really good at highlighting them. DoubleDots is not an imperative language; DoubleDots is reactive. In DoubleDots we can easily spot what state machines we need; where; which states we need; and which transitions. And DoubleDots provide simple means to implement them. **Gestures and other elaborate state machines are simple in DoubleDots**. So. DoubleDots have already implemented a full register of common web gestures such as `swipe`, `fling`, `pinch`, and `pan` that you can use as is, read to understand, and modify and augment to your hearts desire.

9. Smart modularization! In native HTML definitions either bleed or burrow. On one hand we have web component definitions. If a web component wish to define and use other web components inside its `shadowRoot`, it must use the *global* `customElements.define()`. The web components inner definitions are thus added globally, ie. *bleeding* into the rest of the app. On the other hand we have styling web component the `shadowRoot`. Even if you know exactly the element name, the CSS classes, its attributes, etc., if the web component hasn't already *actively exposed* these structures, you *cannot* style it from the outside, no matter how precisely you define the CSS selector in the lightDom. Element styling *burrows*. DoubleDots balances bleeding and burrowing better than native HTML. In DoubleDots all definitions burrow by default, which is needed 99% of the time. However, if you need to, you can explicitly override any reaction or trigger DOM-time. On a *per element* basis. To achieve this, a light restriction is set on *timing* of shadowDom definitions and lightDom overrides. Balance struck.

10. ❤️❤️❤️CSS+DD=BFF❤️❤️❤️. CSS and DoubleDots are Best Friends Forever! CSS *loves* apps that have their state in the DOM. Then you can write visual rules based on the state of attributes and css classes. DoubleDots takes this to the extreme, all state in the DOM. that means that CSS can program against the full state of the app. Can CSS ask for more? (There is only *one* caveat. DoubleDots uses `trigger:reaction:chain` syntax. Mostly, when DoubleDots adds state in the app, such as with gestures, it does so using `gesture:="state"` format or as normal `data="state"` attributes. Or CSS classes. This is super CSS friendly. However, if you needed to query for trigger names regardless of reaction chain, which you don't usually do in DoubleDots, this is not really possible in CSS.)