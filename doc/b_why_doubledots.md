# Why DoubleDots?

>> Everything written here is true. But still. Be forewarned. This is a sales pitch. This is the way we would present the benefits of DoubleDots when we throw causion and humility to the side. We hope you find it inspiring, and enlightening, and that you forgive us for this bluster and temporary lapse in character.

Below are 6 points why DoubleDots is memorable. Once you see HTML throught the lens of DoubleDots, you will never be able to unsee it. It is unforgettable.

1. DoubleDots renovates the **timeline** in HTML. It unifies all the different timers, callbacks, observers, and the native event queue into a single **virtual event loop**. This makes it much easier to understand the different priorities between tasks (promises, micro, meso, macro, etc.). This illustrates not only how to solve and avoid race conditions between these different queues that now are quite obfuscated, but it also illustrate the clear difference between the thread structure `async/await` allows and how these threads should be viewed up against the singularity of the event loop.

2. Adding only ***`:`*** to HTML attribute names DoubleDots enable you to **program rich web apps in HTML only**. Let that sink in.. One grammatical extension to HTML, that fits seamlessly with HTML, and you no longer need to use JS if you don't want to. ***One***! Because of this syntactic elegance, the DoubleDots run-time environment with a complete virtual event loop can be added as a simple drop-in script. Of less than 1000 readable lines of code. But, the main strength of DoubleDots is not its super efficient run-time; the power of DoubleDots grammar is its ability to help you **see the simplicity of how to program directly against the event loop**. The **clear, simple syntax** of DoubleDots give you a **clear, simple tool for thought** for seeing problems and solutions in terms of event loop. Once you understand how you can program directly against the event loop in DoubleDots, you will know how to program directly against any event loop. That insight is the true value.
 
3. React was right! Functions should be understood as "react"ions. Reaction based programming is a *really good* programming philosophy, on par with pure functions, pure data, the event loop, async/await, etc. However, DoubleDots takes the concept of "reaction" to new heights. You ain't seen nothing yet. I promise. In DoubleDots, you can be excused for thinking that *all* functions are reactions. Or reaction chains. Because DoubleDots is based in a landscape and run-time that you already know very well (HTML, js, and a browser), it is **easy** to understand. Because DoubleDots adds only the `:` doubledot and some reactions, it is **simple** to learn. And based *only* on these principles, DoubleDots still shows you the true meaning of reactive programming. DoubleDots ***will forever shape*** the way you see and understand a world of reactions is.

4. DoubleDots provide a **great** debugging experience. DevTools have solved the issue of showing you **data**: what is going on *where and why*. But, *when* things are *going to happen*, the ***why when***, that is still a mystery in DevTools. This mystery is really a headscratcher. And it is due to the many different queues, the many unregistered tasks, and the `async` threads that in modern js apps now run rampant. The virtual event loop in *DoubleDots solves this problem*. DoubleDots will ***show you time***. By registering *everything relevant that happens* in the browser in one linear event loop, and by registering which reaction starts and completes when, DoubleDots can at any point ***list and color code*** completed, awaiting, and queued events, tasks, and reaction chains.

6. Using reactions and triggers, DoubleDots also give new meaning to the concept of state machines. State machines is a recurring problem in HTML (and coding in general). But, imperative languages like JS are not really good at highlighting them. DoubleDots is not an imperative language; DoubleDots is reactive. In DoubleDots we can easily spot what state machines we need; where; which states we need; and which transitions. And DoubleDots provide simple means to implement them. **Gestures and other elaborate state machines are simple in DoubleDots**. So. DoubleDots have already implemented a full register of common web gestures such as `swipe`, `fling`, `pinch`, and `pan` that you can use as is, read to understand, and modify and augment to your hearts desire.

7. Smart modularization! In native HTML definitions either bleed or burrow. On one hand we have web component definitions. If a web component wish to define and use other web components inside its `shadowRoot`, it must use the *global* `customElements.define()`. The web components inner definitions are thus added globally, ie. *bleeding* into the rest of the app. On the other hand we have styling web component the `shadowRoot`. Even if you know exactly the element name, the CSS classes, its attributes, etc., if the web component hasn't already *actively exposed* these structures, you *cannot* style it from the outside, no matter how precisely you define the CSS selector in the lightDom. Element styling *burrows*. DoubleDots balances bleeding and burrowing better than native HTML. In DoubleDots all definitions burrow by default, which is needed 99% of the time. However, if you need to, you can explicitly override any reaction or trigger DOM-time. On a *per element* basis. To achieve this, a light restriction is set on *timing* of shadowDom definitions and lightDom overrides. Balance struck.
