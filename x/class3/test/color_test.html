<body>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    function createLineChart(chartTitle, data, labels, yLabel, colorNames) {
      const datasets = Object.entries(data).map(([key, values], i) => ({
        label: key,
        data: values,
        borderColor: colorNames?.[i] ?? "grey",
        borderWidth: 2,
        fill: false,
        tension: 0.2,
      }));

      document.body.append(document.createElement(`canvas`));
      ctx = document.body.lastElementChild.getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels, // x-axis labels (color names)
          datasets,
        },
        options: {
          onClick: ({ chart }) => {
            chart.data.datasets.forEach(set => set.hidden = false);
            chart.update();
          },
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
              onClick: ({ chart, native: e }, { datasetIndex: I }) => {
                const sets = chart.data.datasets;
                if (!e.ctrlKey)
                  sets[I].hidden = !sets[I].hidden;
                else
                  for (let i = 0; i < sets.length; i++)
                    sets[i].hidden = i !== I;
                chart.update();
              },

            },
            title: {
              display: true,
              text: chartTitle,
            },
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Color Names',
              },
            },
            y: {
              title: {
                display: true,
                text: yLabel,
              },
            },
          },
        },
      });
    }
  </script>

  <script>
    function hexToLinearRgb(hex) {
      hex = hex.slice(1);
      let bigint;
      if (hex.length === 3) {
        bigint = parseInt(hex.split('').map(char => char + char).join(''), 16);
      } else if (hex.length === 6) {
        bigint = parseInt(hex, 16);
      } else {
        throw new Error('Invalid HEX color.');
      }
      const r = ((bigint >> 16) & 255) / 255;
      const g = ((bigint >> 8) & 255) / 255;
      const b = (bigint & 255) / 255;

      const linearize = c => c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      return {
        R: linearize(r),
        G: linearize(g),
        B: linearize(b)
      };
    }

    function linearRgbToXyz({ R, G, B }) {
      const X = 0.4122214708 * R + 0.5363325363 * G + 0.0514459929 * B;
      const Y = 0.2119034982 * R + 0.6806995451 * G + 0.1073969566 * B;
      const Z = 0.0883024619 * R + 0.2817188376 * G + 0.6299787005 * B;
      return { X, Y, Z };
    }

    function xyzToOKLab({ X, Y, Z }) {
      const l = 0.8189330101 * X + 0.3618667424 * Y - 0.1288597137 * Z;
      const m = 0.0329845436 * X + 0.9293118715 * Y + 0.0361456387 * Z;
      const s = 0.0482003018 * X + 0.2643662691 * Y + 0.6338517070 * Z;

      const lCube = Math.cbrt(l);
      const mCube = Math.cbrt(m);
      const sCube = Math.cbrt(s);

      const L = 0.2104542553 * lCube + 0.7936177850 * mCube - 0.0040720468 * sCube;
      const a = 1.9779984951 * lCube - 2.4285922050 * mCube + 0.4505937099 * sCube;
      const b = 0.0259040371 * lCube + 0.7827717662 * mCube - 0.8086757660 * sCube;

      return { L, a, b };
    }

    function oklabToOklch({ L, a, b }) {
      const C = Math.sqrt(a * a + b * b);
      let H = Math.atan2(b, a) * (180 / Math.PI);
      if (H < 0) H += 360;
      return { L, C, H };
    }

    function analyzeHex(hex) {
      const rgb = hexToLinearRgb(hex);
      const xyz = linearRgbToXyz(rgb);
      const lab = xyzToOKLab(xyz);
      const lch = oklabToOklch(lab);
      return { hex, ...rgb, ...xyz, ...lab, ...lch };
    }

    function extractValue(colors, valueFunc) {
      const res = {};
      for (let [name, table] of Object.entries(colors))
        res[name] = Object.values(table).map(valueFunc);
      return res;
    }

    function innerKeyToArray(grandpa) {
      const res = {};
      for (let outer in grandpa)
        for (let inner in grandpa[outer])
          (res[inner] ??= {})[outer] = grandpa[outer][inner];
      return res;
    }

    function analyzeColors(colorMap, name) {
      const res = { ...colorMap };
      for (let name in colorMap)
        for (let [shade, hex] of Object.entries(colorMap[name]))
          res[name][shade] = analyzeHex(hex);
      return res;
    }

    function printGraph(res, prop, colors) {
      const labels = Object.keys(Object.values(res)[0]);
      res = extractValue(res, color => color[prop]);
      createLineChart(prop, res, labels, prop, colors);
    }

    function printColorPalette(colorMap) {
      let str = "";
      for (let [name, table] of Object.entries(colorMap)) {
        str += `<div style="float: left; clear: left; width:7vw; border-top: solid 2px grey;">${name}</div>`;
        for (let [shade, { hex: HEX }] of Object.entries(table))
          str += `<div style="float: left; background-color: ${HEX}; width: 7vw; height: 7vw; vertical-align: bottom; color: grey;">${shade}</div>`;
        str += `<div style="float: left; background-color: black; width:7vw; height: 7vw;">1000</div>`;
      }
      return str;
    }

    window.runColorMap = function (res, props) {
      const greyScale = ["#eee", "#ddd", "#ccc", "#bbb", "#aaa", "#999", "#888", "#777", "#666", "#555", "#444", "#333", "#222", "#111", "#000"];
      const inverse = innerKeyToArray(res);
      for (let prop of props) {
        const colorNames = Object.entries(res).map(([name, table]) => table[400].hex);
        printGraph(res, prop, colorNames);
        printGraph(inverse, prop, greyScale);
      }
      const palette = printColorPalette(res);
      document.body.insertAdjacentHTML('beforeend', palette);
    };

  </script>

  <ol style="float: left;">
    <li>ctrl + click and you select multiple</li>
    <li>click on the legend to hide/show</li>
    <li>click on the chart to reset and show all</li>
  </ol>
  <form action="" style="float: left;">
    <select id="colorMap" multiple size="10" style="width:100px"></select>
    <select id="colorProp" multiple size="10" style="width:100px"></select>
  </form>
  <script type="module">
    import { Palettes } from "./colorPalettes.js";

    const tablesEl = document.querySelector("#colorMap");
    const propsEl = document.querySelector("#colorProp");
    const formEl = document.querySelector("form");
    for (let table in Palettes)
      tablesEl.insertAdjacentHTML('beforeend', `<option>${table}</option>`);
    for (let prop of ["C", "H", "L", "a", "b"])
      propsEl.insertAdjacentHTML('beforeend', `<option>${prop}</option>`);

    formEl.onchange = e => {
      while (formEl.nextElementSibling)
        formEl.nextElementSibling.remove();
      let table = {};
      for (let { value } of tablesEl.selectedOptions)
        for (let [colorName, dict] of Object.entries(Palettes[value]))
          table[colorName + "_" + value.slice(0, 2)] = dict;
      table = Object.fromEntries(Object.entries(table).sort(
        ([, { "500": { H: a } }], [, { "500": { H: b } }]) => b - a
      ));
      const ps = [...propsEl.selectedOptions].map(o => o.value);
      runColorMap(table, ps);
    };
    tablesEl.children[0].selected = true;
    tablesEl.children[6].selected = true;
    // propsEl.children[2].selected = true;
    formEl.dispatchEvent(new Event('change'));
  </script>
</body>