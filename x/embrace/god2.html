<template>
  <div _t: _::fetch:oi.company1:_t:embrace="companies.json" name="{{name}}">
    <h1>{{name}}</h1>
    <ol>
      <h3>List of employees</h3>
      <!-- {{for(employee of employees)}} -->
      -x-x-
      <li>{{$employee.fullname}} is employee number {{$$employee}} for company {{name}}</li>
      <!--{{end}} -->
      -x-x-
      <h4>no more Employees</h4>
    </ol>
  </div>
  <!-- comments with braces, stops the brace for that level until the end comment. -->
</template>

<script type="module">

  function embrace(templ, dataObject) {
    //startUpTime
    if (!this.__embraceRoot) {
      this.__embraceRoot = EmbraceRoot.make(this.ownerElement, templ);
      this.ownerElement.append(templ);
    }
    //embraceTime
    this.__embraceRoot.run(dataObject);
  }

  class EmbraceGet {
    constructor(param) {
      this.param = param;
    }
    get params() {
      return { [this.param]: this.param };
    }
    run(argsDict, dataIn, node, ancestor) {
      return argsDict[this.param];
    }

    static make(str) {
      return str.indexOf(" ") === -1 && new EmbraceGet(str);
    }
  }

  class EmbraceTextNode {
    constructor(segs) {
      !segs[0] && segs.shift();
      !segs[segs.length - 1] && segs.pop();
      this.segs = segs;
    }

    get params() {
      const res = {};
      for (let E of this.segs)
        if (E instanceof EmbraceGet)
          for (let param in E.params)
            res[param] = param;
      return res;
    }

    run(argsDict, dataIn, node, ancestor) {
      let txt = "";
      for (let s of this.segs)
        txt += typeof s == "string" ? s : s.run(argsDict, dataIn, node, ancestor);
      node.textContent = txt;
    }

    static make(txt) {
      //split the segment
      const segs = txt.split(/{{([^}]+)}}/);
      if (segs.length === 1)
        return;
      //convert splits to bigEs
      for (let i = 1; i < segs.length; i += 2) {
        segs[i] = EmbraceGet.make(segs[i].trim()) ?? `{{${segs[i]}}}`;
        if (!(segs[i] instanceof EmbraceGet)) {
          //todo throw this error in the EmbraceExp
          console.error(`invalid embrace expression: ${segs[i]}`);
        }
      }
      return new EmbraceTextNode(segs);
    }
  }

  function compareSmall(old, now) {
    const exact = new Array(now.length);
    const unused = [];
    if (!old?.length)
      return { exact, unused };
    main: for (let o = 0; o < old.length; o++) {
      for (let n = 0; n < now.length; n++) {
        if (!exact[n] && old[o] === now[n]) {
          exact[n] = o;
          continue main;
        }
      }
      unused.push(o);
    }
    return { exact, unused };
  }

  export class LoopCube {
    constructor(embrace) {
      this.embrace = embrace;
      this.now = [];
      this.nowEmbraces = [];
    }

    step(now = []) {
      const old = this.now;
      const oldEmbraces = this.nowEmbraces;

      this.now = now;
      const { exact, unused } = compareSmall(old, now);
      const embraces = new Array(now.length);
      const changed = [];
      for (let n = 0; n < exact.length; n++) {
        const o = exact[n];
        if (o != null) {
          embraces[n] = oldEmbraces[o];
        } else {
          changed.push(n);
          embraces[n] = unused.length ? oldEmbraces[unused.pop()] : this.embrace.clone();
        }
      }
      this.nowEmbraces = embraces;
      const removes = unused.map(o => oldEmbraces[o]);
      return { embraces, removes, changed };
    }
  }


  //todo when we have a template, we can make an engine against that template 1 time.
  //todo and then reuse that engine afterwards. Via cloning and then simply changing the node that
  //todo are connected to the different rules.
  class EmbraceCommentFor {
    constructor(templ, dollarName, listName) {
      this.listName = listName;
      this.dollarName = dollarName;
      this.d = `$${dollarName}`;
      this.dd = `$$${dollarName}`;
      this.templ = templ;
      this.cube = new LoopCube(EmbraceRoot.make(this.templ));
    }

    get params() {
      return { [this.listName]: this.listName };
    }

    run(argsDictionary, dataObject, node, ancestor) {
      const now = argsDictionary[this.listName];
      const { embraces, removes, changed } = this.cube.step(now);
      for (let n of removes) 
        for (let c of n.nodes) //todo make a prop list on the EmbraceRoot to get all the childNodes only.
          if (!(c instanceof Attr))
            c.remove();
      node.after(...embraces.map(e => e.template));
      for (let i of changed) {
        dataObject[this.d] = now[i];
        dataObject[this.dd] = i;
        embraces[i].run(Object.assign({}, argsDictionary), dataObject, undefined, ancestor);
      }
    }

    //naive, no nested control structures yet. no if. no switch. etc. , untested against errors.
    //startUpTime
    static make(txt, tmpl) {
      const ctrlFor = txt.match(/{{\s*for\s*\(\s*([^\s]+)\s+of\s+([^\s)]+)\)\s*}}/);
      if (ctrlFor) {
        const [_, dollarName, listName] = ctrlFor;
        return new EmbraceCommentFor(tmpl, dollarName, listName);
      }
    }
  }


  class DomBranch {

    static COMMENT_START = /{{\s*(for|if).*}}/;
    static COMMENT_END = /{{\s*end\s*}}/;

    static make(docFrag) {
      DomBranch.subsume(docFrag);
      return new DomBranch(docFrag);
    }

    static flatDomNodesAll(docFrag) {
      const res = [];
      const it = document.createNodeIterator(docFrag, NodeFilter.SHOW_ALL);
      for (let n; n = it.nextNode();) {
        res.push(n);
        if (n instanceof Element)
          for (let a of n.attributes)
            res.push(a);
      }
      return res;
    }

    static gobble(commentStart) {
      commentStart.content = document.createDocumentFragment();
      let n = commentStart.nextSibling;
      while (n) {
        if (n instanceof Comment) {
          if (n.textContent.match(DomBranch.COMMENT_END))
            return;
          if (n.textContent.match(DomBranch.COMMENT_START))
            DomBranch.gobble(n);
        }
        const m = n;
        n = n.nextSibling;
        commentStart.content.append(m);
      }
    }

    static subsume(n) {
      function nextUp(n) {
        while (n = n.parentNode)
          if (n.nextSibling)
            return n.nextSibling;
      }
      for (; n; n = n.firstChild ?? n.nextSibling ?? nextUp(n))
        if (n instanceof Comment)
          if (n.textContent.match(DomBranch.COMMENT_START))
            DomBranch.gobble(n);
    }
  }


  class EmbraceRoot {

    static paramDict(listOfExpressions) {
      const params = {};
      for (let e of listOfExpressions.filter(Boolean))
        for (let p in e.params)
          params[p] ??= p.split(".");
      return params;
    }

    static listOfExpressions(listOfNodes) {
      return listOfNodes.map(n => {
        if (n instanceof Text || n instanceof Attr)
          return EmbraceTextNode.make(n.textContent);
        if (n instanceof Comment)
          return EmbraceCommentFor.make(n.textContent, n.content);
      });
    }

    constructor(docFrag) {
      this.template = docFrag;
      this.nodes = DomBranch.flatDomNodesAll(docFrag);
    }

    clone() {
      const e = new EmbraceRoot(this.template.cloneNode(true));
      e.expressions = this.expressions;
      e.paramsDict = this.paramsDict;
      return e;
    }

    run(argsDictionary, dataObject, node, ancestor) {
      //1. make the argumentsDictionary
      for (let param in this.paramsDict)
        argsDictionary[param] ??= this.paramsDict[param].reduce((o, p) => o?.[p], dataObject);
      //2. prep and run rules
      for (let ex, n, i = 0; i < this.expressions.length; i++)
        if (ex = this.expressions[i])
          if (n = this.nodes[i])
            if (n instanceof Attr ? ancestor.contains(n.ownerElement) : ancestor.contains(n))
              ex.run(argsDictionary, dataObject, n, ancestor);
    }

    static make(docFrag) {
      DomBranch.subsume(docFrag);
      const e = new EmbraceRoot(docFrag);
      e.expressions = EmbraceRoot.listOfExpressions(e.nodes);
      e.paramsDict = EmbraceRoot.paramDict(e.expressions);
      return e;
    }
  }

  const templ = document.querySelector('template');
  const e = EmbraceRoot.make(templ.content);
  document.body.append(e.template);
  e.run(
    {},
    { name: "acme", employees: [{ fullname: "lae" }, { fullname: "ivar" }] },
    undefined,
    document.body
  );


</script>